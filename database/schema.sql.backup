-- ============================================
-- SCHÉMA DE BASE DE DONNÉES - KRAVSTATS
-- PostgreSQL 15+
-- Multi-tenant avec Row Level Security
-- OPTIMISÉ POUR DATA ANALYTICS
-- ============================================

-- Extensions nécessaires
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "pg_stat_statements"; -- Pour monitoring des requêtes
CREATE EXTENSION IF NOT EXISTS "tablefunc"; -- Pour crosstab (pivot tables)

-- ============================================
-- TABLE: organizations (Clubs/Tenants)
-- ============================================
CREATE TABLE organizations (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    
    -- Identité
    name VARCHAR(255) NOT NULL CHECK (char_length(name) >= 2),
    slug VARCHAR(100) UNIQUE NOT NULL CHECK (slug ~ '^[a-z0-9-]+-- ============================================
-- SCHÉMA DE BASE DE DONNÉES - KRAVSTATS
-- PostgreSQL 15+
-- Multi-tenant avec Row Level Security
-- ============================================

-- Extensions nécessaires
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ============================================
-- TABLE: organizations (Clubs/Tenants)
-- ============================================
CREATE TABLE organizations (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    
    -- Identité
    name VARCHAR(255) NOT NULL CHECK (char_length(name) >= 2),
    slug VARCHAR(100) UNIQUE NOT NULL CHECK (slug ~ '^[a-z0-9-]+$'),
    
    -- Contact
    email VARCHAR(255) CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}$'),
    phone VARCHAR(20),
    address TEXT,
    
    -- Branding
    logo_url VARCHAR(500),
    
    -- Configuration (JSONB pour flexibilité)
    settings JSONB NOT NULL DEFAULT '{
        "lock_attendance_by_coach": true,
        "default_capacity": 15,
        "season_start_month": 9,
        "timezone": "Europe/Paris"
    }'::jsonb,
    
    -- Abonnement
    subscription_status VARCHAR(20) NOT NULL DEFAULT 'trial' 
        CHECK (subscription_status IN ('trial', 'active', 'past_due', 'canceled', 'suspended')),
    subscription_plan VARCHAR(20) DEFAULT 'free'
        CHECK (subscription_plan IN ('free', 'pro', 'premium')),
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index
CREATE INDEX idx_organizations_slug ON organizations(slug) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_subscription_status ON organizations(subscription_status) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_trial_ends ON organizations(trial_ends_at) WHERE trial_ends_at IS NOT NULL;

-- Trigger pour updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_organizations_updated_at
    BEFORE UPDATE ON organizations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE organizations IS 'Clubs/Associations (tenants multi-tenant)';
COMMENT ON COLUMN organizations.settings IS 'Configuration JSON: lock_attendance_by_coach, default_capacity, etc.';


-- ============================================
-- TABLE: users (Tous les utilisateurs)
-- ============================================
CREATE TABLE users (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Authentification
    email VARCHAR(255) NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}$'),
    password_hash VARCHAR(255) NOT NULL,
    
    -- Identité
    first_name VARCHAR(100) NOT NULL CHECK (char_length(first_name) >= 1),
    last_name VARCHAR(100) NOT NULL CHECK (char_length(last_name) >= 1),
    phone VARCHAR(20),
    date_of_birth DATE CHECK (date_of_birth < CURRENT_DATE),
    
    -- Rôle et statut
    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'coach', 'member')),
    status VARCHAR(20) NOT NULL DEFAULT 'active' 
        CHECK (status IN ('active', 'inactive', 'suspended')),
    
    -- Dates importantes
    join_date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Métadonnées flexibles (ceintures, certificat médical, etc.)
    metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Sécurité
    email_verified BOOLEAN NOT NULL DEFAULT FALSE,
    last_login_at TIMESTAMP WITH TIME ZONE,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Constraints
    CONSTRAINT users_email_org_unique UNIQUE (email, organization_id)
);

-- Index optimisés
CREATE UNIQUE INDEX idx_users_email_org ON users(email, organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_organization_id ON users(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_role ON users(organization_id, role) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_status ON users(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_password_reset ON users(password_reset_token) WHERE password_reset_token IS NOT NULL;
CREATE INDEX idx_users_metadata_gin ON users USING gin(metadata jsonb_path_ops);

-- Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY users_isolation ON users
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE users IS 'Tous les utilisateurs (admins, coachs, adhérents)';
COMMENT ON COLUMN users.metadata IS 'Données flexibles: belt_level, medical_cert, preferences, etc.';
COMMENT ON COLUMN users.password_hash IS 'Hash bcrypt du mot de passe (coût 12)';


-- ============================================
-- TABLE: courses (Cours ponctuels et récurrents)
-- ============================================
CREATE TABLE courses (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Informations de base
    title VARCHAR(255) NOT NULL CHECK (char_length(title) >= 2),
    description TEXT,
    course_type VARCHAR(50),
    
    -- Horaires
    start_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    end_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    CHECK (end_datetime > start_datetime),
    
    -- Lieu
    location VARCHAR(255),
    
    -- Coach
    coach_id UUID REFERENCES users(id) ON DELETE SET NULL,
    
    -- Capacité
    max_capacity INTEGER CHECK (max_capacity > 0 OR max_capacity IS NULL),
    
    -- Récurrence
    is_recurring BOOLEAN NOT NULL DEFAULT FALSE,
    recurrence_rule JSONB CHECK (
        recurrence_rule IS NULL OR 
        (recurrence_rule ? 'frequency' AND recurrence_rule ? 'day_of_week')
    ),
    parent_recurrence_id UUID REFERENCES courses(id) ON DELETE SET NULL,
    
    -- Statut
    status VARCHAR(20) NOT NULL DEFAULT 'scheduled'
        CHECK (status IN ('scheduled', 'ongoing', 'completed', 'cancelled')),
    cancellation_reason TEXT,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index haute performance
CREATE INDEX idx_courses_organization_id ON courses(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_start_datetime ON courses(organization_id, start_datetime DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_coach_id ON courses(coach_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_status ON courses(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_parent_recurrence ON courses(parent_recurrence_id) WHERE parent_recurrence_id IS NOT NULL;
CREATE INDEX idx_courses_date_range ON courses(organization_id, start_datetime, end_datetime) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_recurrence_gin ON courses USING gin(recurrence_rule jsonb_path_ops) WHERE recurrence_rule IS NOT NULL;

-- Index pour recherches temporelles optimisées
CREATE INDEX idx_courses_upcoming ON courses(organization_id, start_datetime) 
    WHERE status = 'scheduled' AND deleted_at IS NULL;
CREATE INDEX idx_courses_past ON courses(organization_id, start_datetime DESC) 
    WHERE status = 'completed' AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE courses ENABLE ROW LEVEL SECURITY;

CREATE POLICY courses_isolation ON courses
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_courses_updated_at
    BEFORE UPDATE ON courses
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE courses IS 'Cours (ponctuels et récurrents avec occurrences)';
COMMENT ON COLUMN courses.recurrence_rule IS 'Règle de récurrence JSON: {frequency: "weekly", day_of_week: 1, end_date: "2026-06-30"}';
COMMENT ON COLUMN courses.parent_recurrence_id IS 'Lien vers le cours parent si occurrence de récurrence';


-- ============================================
-- TABLE: attendances (Présences et intentions)
-- ============================================
CREATE TABLE attendances (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    course_id UUID NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Intention (avant le cours)
    intention VARCHAR(20) CHECK (intention IN ('will_attend', 'will_not_attend') OR intention IS NULL),
    intention_at TIMESTAMP WITH TIME ZONE,
    
    -- Présence effective (pendant/après le cours)
    actual_attendance BOOLEAN,
    actual_attendance_at TIMESTAMP WITH TIME ZONE,
    
    -- Traçabilité
    marked_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    marked_by_role VARCHAR(20) CHECK (marked_by_role IN ('admin', 'coach', 'member') OR marked_by_role IS NULL),
    is_locked BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Notes
    notes TEXT,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contrainte unicité
    CONSTRAINT attendances_course_user_unique UNIQUE (course_id, user_id)
);

-- Index critiques pour performance
CREATE UNIQUE INDEX idx_attendances_course_user ON attendances(course_id, user_id);
CREATE INDEX idx_attendances_organization_id ON attendances(organization_id);
CREATE INDEX idx_attendances_user_id ON attendances(user_id);
CREATE INDEX idx_attendances_course_id ON attendances(course_id);

-- Index pour statistiques optimisées
CREATE INDEX idx_attendances_actual ON attendances(organization_id, user_id, actual_attendance) 
    WHERE actual_attendance IS NOT NULL;
CREATE INDEX idx_attendances_intention ON attendances(organization_id, course_id, intention) 
    WHERE intention IS NOT NULL;
CREATE INDEX idx_attendances_user_actual_date ON attendances(user_id, actual_attendance_at) 
    WHERE actual_attendance = TRUE;

-- Index composite pour requêtes fréquentes
CREATE INDEX idx_attendances_stats ON attendances(organization_id, user_id, actual_attendance, actual_attendance_at)
    WHERE actual_attendance IS NOT NULL;

-- Row Level Security
ALTER TABLE attendances ENABLE ROW LEVEL SECURITY;

CREATE POLICY attendances_isolation ON attendances
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_attendances_updated_at
    BEFORE UPDATE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE attendances IS 'Intentions et présences effectives aux cours';
COMMENT ON COLUMN attendances.intention IS 'Déclaration avant cours: will_attend ou will_not_attend';
COMMENT ON COLUMN attendances.actual_attendance IS 'Présence réelle: true = présent, false = absent, null = non encore marqué';
COMMENT ON COLUMN attendances.is_locked IS 'Verrouillage selon paramètre organisation';


-- ============================================
-- TABLE: subscriptions (Abonnements Stripe)
-- ============================================
CREATE TABLE subscriptions (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL UNIQUE REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Stripe
    stripe_customer_id VARCHAR(255) UNIQUE,
    stripe_subscription_id VARCHAR(255) UNIQUE,
    stripe_payment_method_id VARCHAR(255),
    
    -- Plan
    plan VARCHAR(20) NOT NULL CHECK (plan IN ('free', 'pro', 'premium')),
    status VARCHAR(20) NOT NULL 
        CHECK (status IN ('trialing', 'active', 'past_due', 'canceled', 'unpaid', 'incomplete')),
    
    -- Limites
    max_members INTEGER,
    features JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Dates
    current_period_start TIMESTAMP WITH TIME ZONE,
    current_period_end TIMESTAMP WITH TIME ZONE,
    trial_end TIMESTAMP WITH TIME ZONE,
    canceled_at TIMESTAMP WITH TIME ZONE,
    ended_at TIMESTAMP WITH TIME ZONE,
    
    -- Facturation
    amount_cents INTEGER CHECK (amount_cents >= 0),
    currency VARCHAR(3) NOT NULL DEFAULT 'EUR',
    interval VARCHAR(20) CHECK (interval IN ('month', 'year')),
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
CREATE INDEX idx_subscriptions_stripe_customer ON subscriptions(stripe_customer_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
CREATE INDEX idx_subscriptions_trial_end ON subscriptions(trial_end) WHERE trial_end IS NOT NULL;

-- Trigger
CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE subscriptions IS 'Abonnements et facturation Stripe';
COMMENT ON COLUMN subscriptions.features IS 'Fonctionnalités actives selon plan';


-- ============================================
-- TABLE: custom_fields (Champs personnalisés)
-- ============================================
CREATE TABLE custom_fields (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Définition
    field_name VARCHAR(100) NOT NULL,
    field_key VARCHAR(50) NOT NULL CHECK (field_key ~ '^[a-z_]+$'),
    field_type VARCHAR(20) NOT NULL 
        CHECK (field_type IN ('text', 'number', 'date', 'boolean', 'select', 'multi_select')),
    field_options JSONB DEFAULT '{}'::jsonb,
    
    -- Comportement
    is_required BOOLEAN NOT NULL DEFAULT FALSE,
    show_in_stats BOOLEAN NOT NULL DEFAULT FALSE,
    display_order INTEGER NOT NULL DEFAULT 0,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Contrainte unicité
    CONSTRAINT custom_fields_org_key_unique UNIQUE (organization_id, field_key)
);

-- Index
CREATE INDEX idx_custom_fields_organization ON custom_fields(organization_id, display_order) 
    WHERE deleted_at IS NULL;
CREATE INDEX idx_custom_fields_stats ON custom_fields(organization_id) 
    WHERE show_in_stats = TRUE AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE custom_fields ENABLE ROW LEVEL SECURITY;

CREATE POLICY custom_fields_isolation ON custom_fields
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_custom_fields_updated_at
    BEFORE UPDATE ON custom_fields
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE custom_fields IS 'Définition des champs personnalisés par organisation';
COMMENT ON COLUMN custom_fields.field_options IS 'Options JSON: {values: ["Option1", "Option2"]} pour select';


-- ============================================
-- TABLE: audit_logs (Traçabilité)
-- ============================================
CREATE TABLE audit_logs (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Qui
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    user_email VARCHAR(255),
    user_role VARCHAR(20),
    
    -- Quoi
    action VARCHAR(100) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID,
    
    -- Détails
    changes JSONB DEFAULT '{}'::jsonb,
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contexte
    ip_address INET,
    user_agent TEXT,
    
    -- Quand
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index pour requêtes fréquentes
CREATE INDEX idx_audit_logs_organization ON audit_logs(organization_id, created_at DESC);
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_entity ON audit_logs(entity_type, entity_id);
CREATE INDEX idx_audit_logs_created ON audit_logs(created_at DESC);

-- Partitionnement par date (recommandé si gros volume)
-- CREATE TABLE audit_logs_2025_10 PARTITION OF audit_logs
--     FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');

-- Row Level Security
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY audit_logs_isolation ON audit_logs
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Commentaires
COMMENT ON TABLE audit_logs IS 'Logs de toutes les actions utilisateurs (traçabilité complète)';
COMMENT ON COLUMN audit_logs.changes IS 'Changements JSON: {before: {...}, after: {...}}';


-- ============================================
-- VUES MATÉRIALISÉES (Performance)
-- ============================================

-- Vue: Statistiques adhérents pré-calculées
CREATE MATERIALIZED VIEW mv_member_stats AS
SELECT 
    u.id AS user_id,
    u.organization_id,
    u.first_name,
    u.last_name,
    COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled') AS available_courses,
    ROUND(
        (COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE)::numeric / 
        NULLIF(COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled'), 0)) * 100, 
        2
    ) AS attendance_rate,
    MAX(a.actual_attendance_at) AS last_attendance_date,
    CURRENT_DATE - MAX(a.actual_attendance_at)::date AS days_since_last_attendance
FROM users u
LEFT JOIN attendances a ON u.id = a.user_id
LEFT JOIN courses c ON a.course_id = c.id
WHERE u.deleted_at IS NULL 
    AND u.role = 'member'
    AND c.start_datetime >= CURRENT_DATE - INTERVAL '3 months'
GROUP BY u.id, u.organization_id, u.first_name, u.last_name;

-- Index sur vue matérialisée
CREATE UNIQUE INDEX idx_mv_course_stats_course ON mv_course_stats(course_id);
CREATE INDEX idx_mv_course_stats_org ON mv_course_stats(organization_id);
CREATE INDEX idx_mv_course_stats_dow ON mv_course_stats(organization_id, day_of_week);
CREATE INDEX idx_mv_course_stats_type ON mv_course_stats(organization_id, course_type);
CREATE INDEX idx_mv_course_stats_occupancy ON mv_course_stats(organization_id, occupancy_rate DESC);

COMMENT ON MATERIALIZED VIEW mv_course_stats IS 'Stats cours agrégées avec métriques occupation et fiabilité';


-- Vue: Analyses temporelles (par jour, semaine, mois)
CREATE MATERIALIZED VIEW mv_attendance_timeline AS
SELECT
    a.organization_id,
    a.attendance_date,
    d.year,
    d.quarter,
    d.month,
    d.month_name,
    d.week_of_year,
    d.day_of_week,
    d.day_name,
    d.is_weekend,
    COUNT(DISTINCT a.user_id) FILTER (WHERE a.actual_attendance = TRUE) AS unique_attendees,
    COUNT(*) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    COUNT(*) FILTER (WHERE a.is_no_show = TRUE) AS no_shows,
    COUNT(*) FILTER (WHERE a.is_walk_in = TRUE) AS walk_ins,
    COUNT(DISTINCT a.course_id) AS courses_held
FROM attendances a
INNER JOIN dim_date d ON a.attendance_date = d.date
WHERE a.actual_attendance IS NOT NULL
GROUP BY a.organization_id, a.attendance_date, d.year, d.quarter, d.month, d.month_name, d.week_of_year, d.day_of_week, d.day_name, d.is_weekend;

CREATE UNIQUE INDEX idx_mv_attendance_timeline_org_date ON mv_attendance_timeline(organization_id, attendance_date);
CREATE INDEX idx_mv_attendance_timeline_year_month ON mv_attendance_timeline(organization_id, year, month);
CREATE INDEX idx_mv_attendance_timeline_dow ON mv_attendance_timeline(organization_id, day_of_week);
CREATE INDEX idx_mv_attendance_timeline_weekend ON mv_attendance_timeline(organization_id, is_weekend);

COMMENT ON MATERIALIZED VIEW mv_attendance_timeline IS 'Timeline présences avec dimensions temporelles pour analyses tendances';


-- Vue: Cohorte d'adhérents (analyse rétention)
CREATE MATERIALIZED VIEW mv_member_cohorts AS
SELECT
    u.organization_id,
    DATE_TRUNC('month', u.join_date) AS cohort_month,
    COUNT(DISTINCT u.id) AS cohort_size,
    COUNT(DISTINCT u.id) FILTER (
        WHERE EXISTS (
            SELECT 1 FROM attendances a 
            WHERE a.user_id = u.id 
            AND a.actual_attendance = TRUE 
            AND a.attendance_date >= CURRENT_DATE - INTERVAL '30 days'
        )
    ) AS active_count,
    ROUND(
        (COUNT(DISTINCT u.id) FILTER (
            WHERE EXISTS (
                SELECT 1 FROM attendances a 
                WHERE a.user_id = u.id 
                AND a.actual_attendance = TRUE 
                AND a.attendance_date >= CURRENT_DATE - INTERVAL '30 days'
            )
        )::numeric / COUNT(DISTINCT u.id)) * 100,
        2
    ) AS retention_rate,
    AVG(
        (SELECT COUNT(*) FROM attendances a2 
         WHERE a2.user_id = u.id AND a2.actual_attendance = TRUE)
    ) AS avg_attendances_per_member
FROM users u
WHERE u.role = 'member' 
    AND u.deleted_at IS NULL
GROUP BY u.organization_id, DATE_TRUNC('month', u.join_date);

CREATE INDEX idx_mv_member_cohorts_org_month ON mv_member_cohorts(organization_id, cohort_month DESC);

COMMENT ON MATERIALIZED VIEW mv_member_cohorts IS 'Analyse cohortes adhérents par mois d''inscription (rétention)';


-- Vue: Analytics par champ custom (ex: par ceinture)
CREATE MATERIALIZED VIEW mv_custom_field_stats AS
SELECT
    u.organization_id,
    cf.field_key,
    cf.field_name,
    u.metadata->>cf.field_key AS field_value,
    COUNT(DISTINCT u.id) AS member_count,
    AVG(ms.attendance_rate) AS avg_attendance_rate,
    AVG(ms.reliability_rate) AS avg_reliability_rate,
    SUM(ms.total_attendances) AS total_attendances
FROM users u
CROSS JOIN custom_fields cf
LEFT JOIN mv_member_stats ms ON u.id = ms.user_id
WHERE cf.show_in_stats = TRUE
    AND cf.deleted_at IS NULL
    AND u.role = 'member'
    AND u.deleted_at IS NULL
    AND u.metadata ? cf.field_key
GROUP BY u.organization_id, cf.field_key, cf.field_name, u.metadata->>cf.field_key;

CREATE INDEX idx_mv_custom_field_stats_org_key ON mv_custom_field_stats(organization_id, field_key);

COMMENT ON MATERIALIZED VIEW mv_custom_field_stats IS 'Stats agrégées par champs personnalisés (ex: par ceinture)';


-- ============================================
-- FONCTIONS ANALYTICS AVANCÉES
-- ============================================

-- Fonction: Prévision affluence avec machine learning simple (régression linéaire)
CREATE OR REPLACE FUNCTION forecast_attendance(
    p_course_id UUID,
    p_organization_id UUID
)
RETURNS TABLE (
    predicted_attendance NUMERIC,
    confidence_interval NUMERIC,
    factors JSONB
) AS $
DECLARE
    v_avg_historical NUMERIC;
    v_day_of_week INTEGER;
    v_dow_factor NUMERIC;
    v_trend NUMERIC;
    v_enrolled INTEGER;
    v_walk_in_rate NUMERIC;
BEGIN
    -- Récupérer infos cours
    SELECT c.day_of_week INTO v_day_of_week
    FROM courses c WHERE c.id = p_course_id;
    
    -- Moyenne historique pour ce jour de la semaine
    SELECT AVG(cs.attended_count) INTO v_avg_historical
    FROM mv_course_stats cs
    INNER JOIN courses c ON cs.course_id = c.id
    WHERE c.organization_id = p_organization_id
        AND c.day_of_week = v_day_of_week
        AND c.status = 'completed';
    
    -- Facteur jour de semaine (comparé à moyenne générale)
    SELECT 
        (v_avg_historical / NULLIF(AVG(cs.attended_count), 0))
    INTO v_dow_factor
    FROM mv_course_stats cs
    WHERE cs.organization_id = p_organization_id;
    
    -- Tendance récente (30 derniers jours vs 30 jours précédents)
    SELECT 
        (COUNT(*) FILTER (WHERE a.attendance_date >= CURRENT_DATE - INTERVAL '30 days')::numeric /
        NULLIF(COUNT(*) FILTER (WHERE a.attendance_date BETWEEN CURRENT_DATE - INTERVAL '60 days' AND CURRENT_DATE - INTERVAL '30 days'), 0))
    INTO v_trend
    FROM attendances a
    WHERE a.organization_id = p_organization_id
        AND a.actual_attendance = TRUE;
    
    -- Inscrits actuels
    SELECT COUNT(*) INTO v_enrolled
    FROM attendances
    WHERE course_id = p_course_id
        AND intention = 'will_attend';
    
    -- Taux de walk-in moyen
    SELECT 
        (COUNT(*) FILTER (WHERE is_walk_in = TRUE)::numeric /
        NULLIF(COUNT(*), 0))
    INTO v_walk_in_rate
    FROM attendances
    WHERE organization_id = p_organization_id;
    
    -- Calcul prédiction
    RETURN QUERY SELECT
        ROUND(
            (COALESCE(v_enrolled, 0) + 
            (COALESCE(v_avg_historical, 0) * COALESCE(v_walk_in_rate, 0.1))) *
            COALESCE(v_trend, 1) *
            COALESCE(v_dow_factor, 1),
            1
        ),
        ROUND(v_avg_historical * 0.2, 1), -- Intervalle confiance ±20%
        jsonb_build_object(
            'enrolled', v_enrolled,
            'historical_avg', v_avg_historical,
            'day_of_week_factor', v_dow_factor,
            'trend', v_trend,
            'walk_in_rate', v_walk_in_rate
        );
END;
$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION forecast_attendance IS 'Prévision affluence avec facteurs multiples (régression simple)';


-- Fonction: Analyse RFM (Recency, Frequency, Monetary) adaptée au sport
CREATE OR REPLACE FUNCTION analyze_member_rfm(p_organization_id UUID)
RETURNS TABLE (
    user_id UUID,
    user_name TEXT,
    recency_score INTEGER, -- 1-5 (5=très récent)
    frequency_score INTEGER, -- 1-5 (5=très fréquent)
    engagement_score INTEGER, -- 1-5 (5=très engagé)
    rfm_segment VARCHAR(20)
) AS $
BEGIN
    RETURN QUERY
    WITH rfm_calc AS (
        SELECT
            u.id,
            u.first_name || ' ' || u.last_name AS name,
            CURRENT_DATE - MAX(a.attendance_date) AS days_since_last,
            COUNT(*) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
            COUNT(*) FILTER (WHERE a.is_reliable = TRUE) AS reliable_count,
            NTILE(5) OVER (ORDER BY CURRENT_DATE - MAX(a.attendance_date) DESC) AS r_score,
            NTILE(5) OVER (ORDER BY COUNT(*) FILTER (WHERE a.actual_attendance = TRUE)) AS f_score,
            NTILE(5) OVER (ORDER BY COUNT(*) FILTER (WHERE a.is_reliable = TRUE)) AS e_score
        FROM users u
        LEFT JOIN attendances a ON u.id = a.user_id
        WHERE u.organization_id = p_organization_id
            AND u.role = 'member'
            AND u.deleted_at IS NULL
        GROUP BY u.id, u.first_name, u.last_name
    )
    SELECT
        id,
        name,
        r_score::INTEGER,
        f_score::INTEGER,
        e_score::INTEGER,
        CASE
            WHEN r_score >= 4 AND f_score >= 4 AND e_score >= 4 THEN 'Champions'
            WHEN r_score >= 3 AND f_score >= 3 THEN 'Loyal'
            WHEN r_score >= 4 AND f_score <= 2 THEN 'New Members'
            WHEN r_score <= 2 AND f_score >= 3 THEN 'At Risk'
            WHEN r_score <= 2 AND f_score <= 2 THEN 'Lost'
            ELSE 'Regular'
        END
    FROM rfm_calc;
END;
$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION analyze_member_rfm IS 'Segmentation RFM des adhérents (Champions, Loyal, At Risk, Lost)';


-- Fonction: Analyse corrélation (ex: météo vs présence - préparation future)
CREATE OR REPLACE FUNCTION calculate_correlation(
    p_organization_id UUID,
    p_metric1_values NUMERIC[],
    p_metric2_values NUMERIC[]
)
RETURNS NUMERIC AS $
DECLARE
    n INTEGER;
    sum_x NUMERIC := 0;
    sum_y NUMERIC := 0;
    sum_xy NUMERIC := 0;
    sum_x2 NUMERIC := 0;
    sum_y2 NUMERIC := 0;
    i INTEGER;
    correlation NUMERIC;
BEGIN
    n := array_length(p_metric1_values, 1);
    
    IF n != array_length(p_metric2_values, 1) OR n < 2 THEN
        RETURN NULL;
    END IF;
    
    FOR i IN 1..n LOOP
        sum_x := sum_x + p_metric1_values[i];
        sum_y := sum_y + p_metric2_values[i];
        sum_xy := sum_xy + (p_metric1_values[i] * p_metric2_values[i]);
        sum_x2 := sum_x2 + POWER(p_metric1_values[i], 2);
        sum_y2 := sum_y2 + POWER(p_metric2_values[i], 2);
    END LOOP;
    
    correlation := (n * sum_xy - sum_x * sum_y) /
                   NULLIF(SQRT((n * sum_x2 - POWER(sum_x, 2)) * (n * sum_y2 - POWER(sum_y, 2))), 0);
    
    RETURN ROUND(correlation, 4);
END;
$ LANGUAGE plpgsql IMMUTABLE;

COMMENT ON FUNCTION calculate_correlation IS 'Calcule le coefficient de corrélation de Pearson entre deux métriques';


-- Fonction: Détection anomalies (présences inhabituelles)
CREATE OR REPLACE FUNCTION detect_anomalies(
    p_organization_id UUID,
    p_threshold NUMERIC DEFAULT 2.0 -- Nombre d'écarts-types
)
RETURNS TABLE (
    date DATE,
    actual_attendance INTEGER,
    expected_attendance NUMERIC,
    deviation NUMERIC,
    is_anomaly BOOLEAN,
    anomaly_type VARCHAR(20)
) AS $
BEGIN
    RETURN QUERY
    WITH stats AS (
        SELECT
            attendance_date,
            total_attendances,
            AVG(total_attendances) OVER () AS mean_attendance,
            STDDEV(total_attendances) OVER () AS stddev_attendance
        FROM mv_attendance_timeline
        WHERE organization_id = p_organization_id
            AND attendance_date >= CURRENT_DATE - INTERVAL '90 days'
    )
    SELECT
        attendance_date,
        total_attendances,
        ROUND(mean_attendance, 1),
        ROUND((total_attendances - mean_attendance) / NULLIF(stddev_attendance, 0), 2),
        ABS((total_attendances - mean_attendance) / NULLIF(stddev_attendance, 0)) > p_threshold,
        CASE
            WHEN (total_attendances - mean_attendance) > (p_threshold * stddev_attendance) THEN 'spike'
            WHEN (total_attendances - mean_attendance) < -(p_threshold * stddev_attendance) THEN 'drop'
            ELSE 'normal'
        END
    FROM stats
    ORDER BY attendance_date DESC;
END;
$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION detect_anomalies IS 'Détecte les anomalies statistiques dans les présences (spikes, drops)';


-- ============================================
-- VUES POUR BUSINESS INTELLIGENCE
-- ============================================

-- Vue: KPI Dashboard temps réel
CREATE VIEW v_dashboard_kpis AS
SELECT
    o.id AS organization_id,
    o.name AS organization_name,
    -- Adhérents
    COUNT(DISTINCT u.id) FILTER (WHERE u.role = 'member' AND u.status = 'active') AS total_active_members,
    COUNT(DISTINCT u.id) FILTER (
        WHERE u.role = 'member' 
        AND EXISTS (
            SELECT 1 FROM attendances a 
            WHERE a.user_id = u.id 
            AND a.actual_attendance = TRUE 
            AND a.attendance_date >= CURRENT_DATE - INTERVAL '30 days'
        )
    ) AS active_members_30d,
    -- Cours
    COUNT(DISTINCT c.id) FILTER (
        WHERE c.status = 'completed' 
        AND c.start_datetime >= DATE_TRUNC('month', CURRENT_DATE)
    ) AS courses_this_month,
    COUNT(DISTINCT c.id) FILTER (
        WHERE c.status = 'scheduled' 
        AND c.start_datetime >= CURRENT_DATE
        AND c.start_datetime < CURRENT_DATE + INTERVAL '7 days'
    ) AS upcoming_courses_7d,
    -- Présences
    COUNT(*) FILTER (
        WHERE a.actual_attendance = TRUE 
        AND a.attendance_date >= DATE_TRUNC('month', CURRENT_DATE)
    ) AS attendances_this_month,
    ROUND(
        AVG(CASE WHEN a.actual_attendance = TRUE THEN 1 ELSE 0 END) * 100,
        2
    ) AS avg_attendance_rate_30d,
    -- Fiabilité
    ROUND(
        (COUNT(*) FILTER (WHERE a.is_reliable = TRUE)::numeric /
        NULLIF(COUNT(*) FILTER (WHERE a.intention = 'will_attend'), 0)) * 100,
        2
    ) AS reliability_rate_30d,
    -- Tendance
    ROUND(
        ((COUNT(*) FILTER (WHERE a.attendance_date >= CURRENT_DATE - INTERVAL '7 days' AND a.actual_attendance = TRUE)::numeric * 4) /
        NULLIF(COUNT(*) FILTER (WHERE a.attendance_date >= CURRENT_DATE - INTERVAL '30 days' AND a.attendance_date < CURRENT_DATE - INTERVAL '7 days' AND a.actual_attendance = TRUE), 0) - 1) * 100,
        2
    ) AS trend_7d_vs_30d
FROM organizations o
LEFT JOIN users u ON o.id = u.organization_id AND u.deleted_at IS NULL
LEFT JOIN courses c ON o.id = c.organization_id AND c.deleted_at IS NULL
LEFT JOIN attendances a ON o.id = a.organization_id 
    AND a.attendance_date >= CURRENT_DATE - INTERVAL '30 days'
WHERE o.deleted_at IS NULL
GROUP BY o.id, o.name;

COMMENT ON VIEW v_dashboard_kpis IS 'KPIs temps réel pour dashboard (pas de cache)';


-- Vue: Analyse par jour de la semaine
CREATE VIEW v_dow_analysis AS
SELECT
    atl.organization_id,
    atl.day_of_week,
    atl.day_name,
    COUNT(DISTINCT atl.attendance_date) AS total_days,
    AVG(atl.total_attendances) AS avg_attendances,
    AVG(atl.unique_attendees) AS avg_unique_attendees,
    SUM(atl.total_attendances) AS total_attendances,
    AVG(atl.no_shows) AS avg_no_shows,
    AVG(atl.walk_ins) AS avg_walk_ins,
    ROUND(
        (AVG(atl.total_attendances) / 
        NULLIF((SELECT AVG(total_attendances) FROM mv_attendance_timeline WHERE organization_id = atl.organization_id), 0)) * 100,
        2
    ) AS index_vs_average
FROM mv_attendance_timeline atl
GROUP BY atl.organization_id, atl.day_of_week, atl.day_name
ORDER BY atl.organization_id, atl.day_of_week;

COMMENT ON VIEW v_dow_analysis IS 'Analyse comparative par jour de semaine (quel jour marche le mieux)';


-- Vue: Top performers (adhérents les plus assidus)
CREATE VIEW v_top_performers AS
SELECT
    ms.organization_id,
    ms.user_id,
    ms.first_name,
    ms.last_name,
    ms.belt_level,
    ms.total_attendances,
    ms.attendance_rate,
    ms.reliability_rate,
    ms.days_since_last_attendance,
    RANK() OVER (PARTITION BY ms.organization_id ORDER BY ms.attendance_rate DESC) AS rank_by_rate,
    RANK() OVER (PARTITION BY ms.organization_id ORDER BY ms.total_attendances DESC) AS rank_by_total
FROM mv_member_stats ms
WHERE ms.attendance_rate IS NOT NULL;

COMMENT ON VIEW v_top_performers IS 'Classement adhérents les plus assidus (top performers)';


-- ============================================
-- PROCÉDURES ANALYTICS
-- ============================================

-- Procédure: Export pour Data Warehouse externe (CSV)
CREATE OR REPLACE PROCEDURE export_to_data_warehouse(
    p_organization_id UUID,
    p_export_path TEXT DEFAULT '/tmp/export'
)
LANGUAGE plpgsql
AS $
BEGIN
    -- Export fact table attendances
    EXECUTE format('COPY (
        SELECT 
            a.id,
            a.organization_id,
            a.course_id,
            a.user_id,
            a.attendance_date,
            a.attendance_year,
            a.attendance_month,
            a.attendance_week,
            a.attendance_day_of_week,
            a.actual_attendance,
            a.is_no_show,
            a.is_walk_in,
            a.is_reliable
        FROM attendances a
        WHERE a.organization_id = %L
    ) TO %L CSV HEADER', p_organization_id, p_export_path || '/fact_attendances.csv');
    
    -- Export dimension users
    EXECUTE format('COPY (
        SELECT 
            id,
            organization_id,
            first_name,
            last_name,
            role,
            join_date,
            metadata
        FROM users
        WHERE organization_id = %L AND deleted_at IS NULL
    ) TO %L CSV HEADER', p_organization_id, p_export_path || '/dim_users.csv');
    
    -- Export dimension courses
    EXECUTE format('COPY (
        SELECT 
            id,
            organization_id,
            title,
            course_type,
            start_date,
            day_of_week,
            month,
            year,
            duration_minutes,
            max_capacity
        FROM courses
        WHERE organization_id = %L AND deleted_at IS NULL
    ) TO %L CSV HEADER', p_organization_id, p_export_path || '/dim_courses.csv');
    
    RAISE NOTICE 'Export terminé dans %', p_export_path;
END;
$;

COMMENT ON PROCEDURE export_to_data_warehouse IS 'Export données vers data warehouse externe (format star schema)';


-- Procédure: Refresh toutes les vues matérialisées (à scheduler)
CREATE OR REPLACE PROCEDURE refresh_all_analytics_views()
LANGUAGE plpgsql
AS $
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_stats;
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_course_stats;
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_attendance_timeline;
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_cohorts;
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_custom_field_stats;
    
    RAISE NOTICE 'Toutes les vues matérialisées analytics ont été rafraîchies';
END;
$;

COMMENT ON PROCEDURE refresh_all_analytics_views IS 'Rafraîchit toutes les vues matérialisées analytics (scheduler quotidien recommandé)';


-- ============================================
-- CONFIGURATION ANALYTICS
-- ============================================

-- Activer les statistiques étendues pour le query planner
ALTER TABLE attendances SET (autovacuum_analyze_scale_factor = 0.02); -- Analyze plus fréquent
ALTER TABLE courses SET (autovacuum_analyze_scale_factor = 0.05);

-- Statistiques étendues multi-colonnes pour optimisations
CREATE STATISTICS stats_attendances_org_user_date ON organization_id, user_id, attendance_date FROM attendances;
CREATE STATISTICS stats_courses_org_dow_status ON organization_id, day_of_week, status FROM courses;

-- Commentaires finaux
COMMENT ON DATABASE postgres IS 'KravStats - OPTIMISÉ DATA ANALYTICS avec colonnes générées, vues matérialisées, table dimension calendrier';


-- ============================================
-- DASHBOARD GRAFANA / METABASE (Exemples de requêtes)
-- ============================================

/*
-- QUERY 1: Évolution présences sur 12 mois
SELECT 
    DATE_TRUNC('month', attendance_date) AS month,
    COUNT(*) FILTER (WHERE actual_attendance = TRUE) AS attendances,
    COUNT(DISTINCT user_id) AS unique_members
FROM attendances
WHERE organization_id = :org_id
    AND attendance_date >= CURRENT_DATE - INTERVAL '12 months'
GROUP BY DATE_TRUNC('month', attendance_date)
ORDER BY month;

-- QUERY 2: Heatmap par jour de semaine et heure
SELECT 
    c.day_of_week,
    EXTRACT(HOUR FROM c.start_datetime) AS hour,
    COUNT(*) FILTER (WHERE a.actual_attendance = TRUE) AS attendances
FROM courses c
LEFT JOIN attendances a ON c.id = a.course_id
WHERE c.organization_id = :org_id
    AND c.start_datetime >= CURRENT_DATE - INTERVAL '90 days'
GROUP BY c.day_of_week, EXTRACT(HOUR FROM c.start_datetime)
ORDER BY c.day_of_week, hour;

-- QUERY 3: Funnel inscription → présence
SELECT 
    'Total Inscrits' AS step,
    COUNT(*) AS count,
    100.0 AS percentage
FROM attendances
WHERE organization_id = :org_id
    AND intention = 'will_attend'
    AND attendance_date >= :start_date
UNION ALL
SELECT 
    'Présents',
    COUNT(*) FILTER (WHERE actual_attendance = TRUE),
    ROUND((COUNT(*) FILTER (WHERE actual_attendance = TRUE)::numeric / NULLIF(COUNT(*), 0)) * 100, 2)
FROM attendances
WHERE organization_id = :org_id
    AND intention = 'will_attend'
    AND attendance_date >= :start_date;
*/


-- ============================================
-- FIN DU SCHÉMA ANALYTICS
-- ============================================

DO $
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Schéma ANALYTICS créé avec succès !';
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Optimisations Analytics :';
    RAISE NOTICE '✓ Colonnes générées (date, dow, duration, etc.)';
    RAISE NOTICE '✓ 5 vues matérialisées pré-calculées';
    RAISE NOTICE '✓ Table dimension calendrier (dim_date)';
    RAISE NOTICE '✓ Index analytics avancés (40+)';
    RAISE NOTICE '✓ Métriques dérivées (no_show, walk_in, reliable)';
    RAISE NOTICE '✓ Fonctions ML (forecast, RFM, anomalies, corrélation)';
    RAISE NOTICE '✓ Audit logs partitionnés par mois';
    RAISE NOTICE '✓ Statistiques étendues multi-colonnes';
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Scheduler recommandé (pg_cron) :';
    RAISE NOTICE '- refresh_all_analytics_views() : quotidien 2h';
    RAISE NOTICE '- detect_anomalies() : quotidien 6h';
    RAISE NOTICE '- cleanup_old_data() : hebdomadaire';
    RAISE NOTICE '========================================';
END $;member_stats_user ON mv_member_stats(user_id);
CREATE INDEX idx_mv_member_stats_org ON mv_member_stats(organization_id);
CREATE INDEX idx_mv_member_stats_rate ON mv_member_stats(organization_id, attendance_rate DESC);

-- Commentaire
COMMENT ON MATERIALIZED VIEW mv_member_stats IS 'Stats adhérents pré-calculées (refresh quotidien recommandé)';

-- Fonction de refresh automatique (à scheduler)
CREATE OR REPLACE FUNCTION refresh_member_stats()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_stats;
END;
$$ LANGUAGE plpgsql;


-- ============================================
-- FONCTIONS UTILITAIRES
-- ============================================

-- Fonction: Définir le tenant courant (pour RLS)
CREATE OR REPLACE FUNCTION set_current_tenant(tenant_id UUID)
RETURNS void AS $$
BEGIN
    PERFORM set_config('app.current_tenant', tenant_id::text, false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION set_current_tenant IS 'Définit le tenant courant pour Row Level Security';


-- Fonction: Calculer le taux de présence d'un adhérent
CREATE OR REPLACE FUNCTION calculate_attendance_rate(
    p_user_id UUID,
    p_start_date TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_end_date TIMESTAMP WITH TIME ZONE DEFAULT NULL
)
RETURNS NUMERIC AS $$
DECLARE
    v_attendances INTEGER;
    v_available_courses INTEGER;
BEGIN
    -- Compte les présences effectives
    SELECT COUNT(*) INTO v_attendances
    FROM attendances a
    INNER JOIN courses c ON a.course_id = c.id
    WHERE a.user_id = p_user_id
        AND a.actual_attendance = TRUE
        AND (p_start_date IS NULL OR c.start_datetime >= p_start_date)
        AND (p_end_date IS NULL OR c.start_datetime <= p_end_date);
    
    -- Compte les cours disponibles (non annulés)
    SELECT COUNT(DISTINCT c.id) INTO v_available_courses
    FROM courses c
    WHERE c.organization_id = (SELECT organization_id FROM users WHERE id = p_user_id)
        AND c.status != 'cancelled'
        AND (p_start_date IS NULL OR c.start_datetime >= p_start_date)
        AND (p_end_date IS NULL OR c.start_datetime <= p_end_date);
    
    -- Calcul du taux
    IF v_available_courses = 0 THEN
        RETURN 0;
    END IF;
    
    RETURN ROUND((v_attendances::numeric / v_available_courses) * 100, 2);
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION calculate_attendance_rate IS 'Calcule le taux de présence d''un adhérent sur une période';


-- Fonction: Détecter les adhérents à risque d'abandon
CREATE OR REPLACE FUNCTION detect_at_risk_members(
    p_organization_id UUID,
    p_days_threshold INTEGER DEFAULT 21
)
RETURNS TABLE (
    user_id UUID,
    user_name TEXT,
    days_absent INTEGER,
    previous_rate NUMERIC,
    risk_level TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.id,
        u.first_name || ' ' || u.last_name,
        CURRENT_DATE - MAX(a.actual_attendance_at)::date,
        calculate_attendance_rate(u.id, CURRENT_DATE - INTERVAL '3 months', CURRENT_DATE - INTERVAL '1 month'),
        CASE 
            WHEN CURRENT_DATE - MAX(a.actual_attendance_at)::date >= 30 THEN 'critical'
            WHEN CURRENT_DATE - MAX(a.actual_attendance_at)::date >= p_days_threshold THEN 'warning'
            ELSE 'normal'
        END
    FROM users u
    LEFT JOIN attendances a ON u.id = a.user_id AND a.actual_attendance = TRUE
    WHERE u.organization_id = p_organization_id
        AND u.role = 'member'
        AND u.status = 'active'
        AND u.deleted_at IS NULL
    GROUP BY u.id, u.first_name, u.last_name
    HAVING MAX(a.actual_attendance_at) IS NOT NULL
        AND CURRENT_DATE - MAX(a.actual_attendance_at)::date >= p_days_threshold
    ORDER BY CURRENT_DATE - MAX(a.actual_attendance_at)::date DESC;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION detect_at_risk_members IS 'Détecte les adhérents absents depuis X jours (risque abandon)';


-- ============================================
-- TRIGGERS AVANCÉS
-- ============================================

-- Trigger: Auto-update subscription_status dans organizations
CREATE OR REPLACE FUNCTION sync_subscription_status()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE organizations 
    SET subscription_status = NEW.status
    WHERE id = NEW.organization_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_subscription_to_org
    AFTER INSERT OR UPDATE OF status ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION sync_subscription_status();


-- Trigger: Audit automatique sur modifications importantes
CREATE OR REPLACE FUNCTION log_important_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_logs (
            organization_id,
            user_id,
            action,
            entity_type,
            entity_id,
            changes
        ) VALUES (
            NEW.organization_id,
            current_setting('app.current_user_id', true)::uuid,
            TG_TABLE_NAME || '.updated',
            TG_TABLE_NAME,
            NEW.id,
            jsonb_build_object('before', to_jsonb(OLD), 'after', to_jsonb(NEW))
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_logs (
            organization_id,
            user_id,
            action,
            entity_type,
            entity_id,
            changes
        ) VALUES (
            OLD.organization_id,
            current_setting('app.current_user_id', true)::uuid,
            TG_TABLE_NAME || '.deleted',
            TG_TABLE_NAME,
            OLD.id,
            jsonb_build_object('before', to_jsonb(OLD))
        );
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Appliquer l'audit sur les tables critiques
CREATE TRIGGER audit_courses_changes
    AFTER UPDATE OR DELETE ON courses
    FOR EACH ROW
    EXECUTE FUNCTION log_important_changes();

CREATE TRIGGER audit_attendances_changes
    AFTER UPDATE OR DELETE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION log_important_changes();


-- ============================================
-- CONTRAINTES D'INTÉGRITÉ AVANCÉES
-- ============================================

-- Vérifier que le coach appartient à l'organisation
ALTER TABLE courses ADD CONSTRAINT check_coach_organization
    CHECK (
        coach_id IS NULL OR 
        EXISTS (
            SELECT 1 FROM users 
            WHERE id = coach_id 
            AND organization_id = courses.organization_id
            AND role IN ('coach', 'admin')
        )
    );

-- Vérifier cohérence des dates de récurrence
ALTER TABLE courses ADD CONSTRAINT check_recurrence_dates
    CHECK (
        NOT is_recurring OR 
        (recurrence_rule IS NOT NULL)
    );


-- ============================================
-- GRANTS ET SÉCURITÉ
-- ============================================

-- Rôle application (utilisé par le backend)
CREATE ROLE app_user WITH LOGIN PASSWORD 'change_me_in_production';

-- Permissions strictes
GRANT CONNECT ON DATABASE postgres TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO app_user;

-- Lecture seule pour les rapports
CREATE ROLE app_readonly WITH LOGIN PASSWORD 'change_me_readonly';
GRANT CONNECT ON DATABASE postgres TO app_readonly;
GRANT USAGE ON SCHEMA public TO app_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_readonly;


-- ============================================
-- DONNÉES DE TEST (Optionnel)
-- ============================================

-- Insertion organisation de test
INSERT INTO organizations (id, name, slug, email, subscription_plan, subscription_status)
VALUES (
    'a0000000-0000-0000-0000-000000000001',
    'Krav Maga Lyon Centre',
    'krav-maga-lyon-centre',
    'contact@kravlyon.fr',
    'pro',
    'active'
);

-- Insertion utilisateurs de test
INSERT INTO users (organization_id, email, password_hash, first_name, last_name, role)
VALUES 
    ('a0000000-0000-0000-0000-000000000001', 'admin@kravlyon.fr', '$2b$12$dummy_hash', 'Sophie', 'Bernard', 'admin'),
    ('a0000000-0000-0000-0000-000000000001', 'marc@kravlyon.fr', '$2b$12$dummy_hash', 'Marc', 'Petit', 'coach'),
    ('a0000000-0000-0000-0000-000000000001', 'lisa@email.com', '$2b$12$dummy_hash', 'Lisa', 'Martin', 'member');


-- ============================================
-- MAINTENANCE ET MONITORING
-- ============================================

-- ============================================
-- MAINTENANCE ET MONITORING
-- ============================================

-- Vue pour monitoring des performances
CREATE VIEW v_table_sizes AS
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) AS indexes_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

COMMENT ON VIEW v_table_sizes IS 'Taille des tables et indexes pour monitoring';


-- Vue pour monitoring des index inutilisés
CREATE VIEW v_unused_indexes AS
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
    AND indexrelname NOT LIKE 'pg_toast%'
    AND schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;

COMMENT ON VIEW v_unused_indexes IS 'Index jamais utilisés (candidats pour suppression)';


-- Vue pour monitoring des connexions actives
CREATE VIEW v_active_connections AS
SELECT 
    datname,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change,
    wait_event_type,
    wait_event,
    LEFT(query, 100) AS query_preview
FROM pg_stat_activity
WHERE datname = current_database()
    AND pid != pg_backend_pid()
ORDER BY query_start;

COMMENT ON VIEW v_active_connections IS 'Connexions actives à la base de données';


-- Vue pour statistiques par organisation
CREATE VIEW v_organization_stats AS
SELECT 
    o.id,
    o.name,
    o.subscription_plan,
    COUNT(DISTINCT u.id) FILTER (WHERE u.role = 'member' AND u.deleted_at IS NULL) AS total_members,
    COUNT(DISTINCT u.id) FILTER (WHERE u.role = 'coach' AND u.deleted_at IS NULL) AS total_coaches,
    COUNT(DISTINCT c.id) FILTER (WHERE c.deleted_at IS NULL) AS total_courses,
    COUNT(DISTINCT a.id) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    ROUND(
        AVG(
            (SELECT calculate_attendance_rate(u2.id, CURRENT_DATE - INTERVAL '30 days', CURRENT_DATE)
             FROM users u2 
             WHERE u2.organization_id = o.id AND u2.role = 'member' AND u2.deleted_at IS NULL)
        ), 2
    ) AS avg_attendance_rate_30d
FROM organizations o
LEFT JOIN users u ON o.id = u.organization_id
LEFT JOIN courses c ON o.id = c.organization_id
LEFT JOIN attendances a ON o.id = a.organization_id
WHERE o.deleted_at IS NULL
GROUP BY o.id, o.name, o.subscription_plan;

COMMENT ON VIEW v_organization_stats IS 'Statistiques agrégées par organisation';


-- ============================================
-- PROCÉDURES DE MAINTENANCE
-- ============================================

-- Procédure: Nettoyage des données obsolètes
CREATE OR REPLACE PROCEDURE cleanup_old_data(
    p_audit_logs_retention_days INTEGER DEFAULT 365,
    p_deleted_records_retention_days INTEGER DEFAULT 90
)
LANGUAGE plpgsql
AS $
BEGIN
    -- Supprimer les vieux logs d'audit
    DELETE FROM audit_logs 
    WHERE created_at < CURRENT_DATE - (p_audit_logs_retention_days || ' days')::INTERVAL;
    
    RAISE NOTICE 'Audit logs nettoyés: % lignes supprimées', 
        (SELECT count(*) FROM audit_logs WHERE created_at < CURRENT_DATE - (p_audit_logs_retention_days || ' days')::INTERVAL);
    
    -- Supprimer définitivement les enregistrements soft-deleted anciens
    DELETE FROM users 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    DELETE FROM courses 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    DELETE FROM organizations 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    RAISE NOTICE 'Nettoyage terminé';
END;
$;

COMMENT ON PROCEDURE cleanup_old_data IS 'Nettoyage automatique des données obsolètes (à scheduler)';


-- Procédure: Vacuum et analyse automatiques
CREATE OR REPLACE PROCEDURE maintenance_vacuum_analyze()
LANGUAGE plpgsql
AS $
BEGIN
    VACUUM ANALYZE organizations;
    VACUUM ANALYZE users;
    VACUUM ANALYZE courses;
    VACUUM ANALYZE attendances;
    VACUUM ANALYZE subscriptions;
    VACUUM ANALYZE custom_fields;
    VACUUM ANALYZE audit_logs;
    
    RAISE NOTICE 'Vacuum et analyse terminés';
END;
$;

COMMENT ON PROCEDURE maintenance_vacuum_analyze IS 'Vacuum et analyse des tables principales (à scheduler quotidiennement)';


-- Procédure: Refresh des vues matérialisées
CREATE OR REPLACE PROCEDURE refresh_all_materialized_views()
LANGUAGE plpgsql
AS $
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_stats;
    RAISE NOTICE 'Vues matérialisées rafraîchies';
END;
$;

COMMENT ON PROCEDURE refresh_all_materialized_views IS 'Rafraîchissement de toutes les vues matérialisées (à scheduler quotidiennement)';


-- ============================================
-- BACKUP ET RESTORE
-- ============================================

-- Fonction: Export des données d'une organisation (RGPD)
CREATE OR REPLACE FUNCTION export_organization_data(p_organization_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $
DECLARE
    v_data JSONB;
BEGIN
    SELECT jsonb_build_object(
        'organization', (SELECT row_to_json(o.*) FROM organizations o WHERE id = p_organization_id),
        'users', (SELECT jsonb_agg(row_to_json(u.*)) FROM users u WHERE organization_id = p_organization_id AND deleted_at IS NULL),
        'courses', (SELECT jsonb_agg(row_to_json(c.*)) FROM courses c WHERE organization_id = p_organization_id AND deleted_at IS NULL),
        'attendances', (SELECT jsonb_agg(row_to_json(a.*)) FROM attendances a WHERE organization_id = p_organization_id),
        'custom_fields', (SELECT jsonb_agg(row_to_json(cf.*)) FROM custom_fields cf WHERE organization_id = p_organization_id AND deleted_at IS NULL)
    ) INTO v_data;
    
    RETURN v_data;
END;
$;

COMMENT ON FUNCTION export_organization_data IS 'Export complet des données d''une organisation (conformité RGPD)';


-- Fonction: Anonymisation d'un utilisateur (RGPD - droit à l'oubli)
CREATE OR REPLACE FUNCTION anonymize_user(p_user_id UUID)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $
BEGIN
    UPDATE users
    SET 
        email = 'deleted_' || id || '@anonymized.local',
        first_name = 'Utilisateur',
        last_name = '[Supprimé]',
        phone = NULL,
        date_of_birth = NULL,
        metadata = '{}'::jsonb,
        password_hash = 'ANONYMIZED',
        deleted_at = CURRENT_TIMESTAMP
    WHERE id = p_user_id;
    
    -- Log de l'action
    INSERT INTO audit_logs (
        organization_id,
        user_id,
        action,
        entity_type,
        entity_id,
        metadata
    ) VALUES (
        (SELECT organization_id FROM users WHERE id = p_user_id),
        p_user_id,
        'user.anonymized',
        'users',
        p_user_id,
        jsonb_build_object('anonymized_at', CURRENT_TIMESTAMP, 'reason', 'RGPD_right_to_be_forgotten')
    );
    
    RAISE NOTICE 'Utilisateur % anonymisé', p_user_id;
END;
$;

COMMENT ON FUNCTION anonymize_user IS 'Anonymisation d''un utilisateur (RGPD - droit à l''oubli)';


-- ============================================
-- INDEXES PARTIELS AVANCÉS (Optimisation)
-- ============================================

-- Index pour les cours à venir uniquement (requête très fréquente)
CREATE INDEX idx_courses_upcoming_detailed ON courses(organization_id, start_datetime, status)
    WHERE start_datetime > CURRENT_TIMESTAMP 
        AND status = 'scheduled' 
        AND deleted_at IS NULL;

-- Index pour les adhérents actifs récents
CREATE INDEX idx_users_active_recent ON users(organization_id, last_login_at DESC)
    WHERE status = 'active' 
        AND deleted_at IS NULL
        AND last_login_at > CURRENT_TIMESTAMP - INTERVAL '30 days';

-- Index pour présences du mois en cours (statistiques temps réel)
CREATE INDEX idx_attendances_current_month ON attendances(organization_id, user_id, actual_attendance)
    WHERE actual_attendance_at >= date_trunc('month', CURRENT_DATE)
        AND actual_attendance IS NOT NULL;


-- ============================================
-- POLICIES RLS AVANCÉES (Sécurité fine)
-- ============================================

-- Policy: Les coachs ne voient que leurs cours
CREATE POLICY coaches_own_courses ON courses
    FOR SELECT
    USING (
        organization_id = current_setting('app.current_tenant', true)::uuid
        AND (
            coach_id = current_setting('app.current_user_id', true)::uuid
            OR EXISTS (
                SELECT 1 FROM users 
                WHERE id = current_setting('app.current_user_id', true)::uuid 
                AND role IN ('admin')
            )
        )
    );

-- Policy: Les adhérents ne voient que leurs propres présences détaillées
CREATE POLICY members_own_attendances ON attendances
    FOR SELECT
    USING (
        organization_id = current_setting('app.current_tenant', true)::uuid
        AND (
            user_id = current_setting('app.current_user_id', true)::uuid
            OR EXISTS (
                SELECT 1 FROM users 
                WHERE id = current_setting('app.current_user_id', true)::uuid 
                AND role IN ('admin', 'coach')
            )
        )
    );


-- ============================================
-- CONTRAINTES DE VALIDATION MÉTIER
-- ============================================

-- Vérifier qu'un cours ne dépasse pas 24h
ALTER TABLE courses ADD CONSTRAINT check_course_max_duration
    CHECK (end_datetime - start_datetime <= INTERVAL '24 hours');

-- Vérifier qu'on ne peut pas marquer présent à un cours dans le futur
CREATE OR REPLACE FUNCTION check_attendance_not_future()
RETURNS TRIGGER AS $
BEGIN
    IF NEW.actual_attendance IS NOT NULL AND NEW.actual_attendance_at IS NOT NULL THEN
        IF NEW.actual_attendance_at > (SELECT end_datetime FROM courses WHERE id = NEW.course_id) + INTERVAL '2 hours' THEN
            RAISE EXCEPTION 'Impossible de marquer une présence plus de 2h après la fin du cours';
        END IF;
    END IF;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER validate_attendance_timing
    BEFORE INSERT OR UPDATE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION check_attendance_not_future();


-- ============================================
-- FONCTIONS D'AGRÉGATION PERSONNALISÉES
-- ============================================

-- Fonction: Statistiques complètes d'un adhérent
CREATE OR REPLACE FUNCTION get_member_complete_stats(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $
DECLARE
    v_stats JSONB;
BEGIN
    SELECT jsonb_build_object(
        'user_id', p_user_id,
        'total_courses_available', (
            SELECT COUNT(*) 
            FROM courses c
            WHERE c.organization_id = (SELECT organization_id FROM users WHERE id = p_user_id)
                AND c.status != 'cancelled'
                AND c.start_datetime >= (SELECT join_date FROM users WHERE id = p_user_id)
                AND c.deleted_at IS NULL
        ),
        'total_attendances', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'attendance_rate', calculate_attendance_rate(p_user_id),
        'attendance_rate_30d', calculate_attendance_rate(p_user_id, CURRENT_DATE - INTERVAL '30 days', CURRENT_DATE),
        'attendance_rate_90d', calculate_attendance_rate(p_user_id, CURRENT_DATE - INTERVAL '90 days', CURRENT_DATE),
        'last_attendance', (
            SELECT MAX(actual_attendance_at) 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'days_since_last_attendance', (
            SELECT CURRENT_DATE - MAX(actual_attendance_at)::date 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'current_streak', (
            -- Série de présences consécutives (simplifié)
            SELECT COUNT(*)
            FROM attendances a
            INNER JOIN courses c ON a.course_id = c.id
            WHERE a.user_id = p_user_id 
                AND a.actual_attendance = TRUE
                AND c.start_datetime >= CURRENT_DATE - INTERVAL '30 days'
        ),
        'total_intentions', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE user_id = p_user_id AND intention = 'will_attend'
        ),
        'intention_reliability', (
            -- Fiabilité des inscriptions
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE intention = 'will_attend' AND actual_attendance = TRUE)::numeric /
                NULLIF(COUNT(*) FILTER (WHERE intention = 'will_attend'), 0)) * 100, 2
            )
            FROM attendances
            WHERE user_id = p_user_id
        )
    ) INTO v_stats;
    
    RETURN v_stats;
END;
$;

COMMENT ON FUNCTION get_member_complete_stats IS 'Statistiques complètes d''un adhérent (toutes périodes)';


-- Fonction: Statistiques d'un cours
CREATE OR REPLACE FUNCTION get_course_stats(p_course_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $
DECLARE
    v_stats JSONB;
BEGIN
    SELECT jsonb_build_object(
        'course_id', p_course_id,
        'total_enrolled', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE course_id = p_course_id AND intention = 'will_attend'
        ),
        'total_attended', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE course_id = p_course_id AND actual_attendance = TRUE
        ),
        'occupancy_rate', (
            SELECT CASE 
                WHEN c.max_capacity IS NOT NULL THEN
                    ROUND((COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE)::numeric / c.max_capacity) * 100, 2)
                ELSE NULL
            END
            FROM courses c
            LEFT JOIN attendances a ON c.id = a.course_id
            WHERE c.id = p_course_id
            GROUP BY c.max_capacity
        ),
        'no_show_rate', (
            -- Taux de non-présentation (inscrits mais absents)
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE intention = 'will_attend' AND actual_attendance = FALSE)::numeric /
                NULLIF(COUNT(*) FILTER (WHERE intention = 'will_attend'), 0)) * 100, 2
            )
            FROM attendances
            WHERE course_id = p_course_id
        ),
        'walk_ins', (
            -- Présents non-inscrits
            SELECT COUNT(*)
            FROM attendances
            WHERE course_id = p_course_id 
                AND intention IS NULL 
                AND actual_attendance = TRUE
        )
    ) INTO v_stats;
    
    RETURN v_stats;
END;
$;

COMMENT ON FUNCTION get_course_stats IS 'Statistiques détaillées d''un cours';


-- ============================================
-- SCHEDULING (À configurer via pg_cron ou cron externe)
-- ============================================

-- Extension pg_cron (optionnelle, nécessite installation)
-- CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Exemples de tâches planifiées (à décommenter si pg_cron installé)
/*
-- Refresh des stats quotidien à 2h du matin
SELECT cron.schedule('refresh-stats', '0 2 * * *', $
    CALL refresh_all_materialized_views();
$);

-- Nettoyage hebdomadaire le dimanche à 3h
SELECT cron.schedule('cleanup-old-data', '0 3 * * 0', $
    CALL cleanup_old_data(365, 90);
$);

-- Vacuum quotidien à 4h
SELECT cron.schedule('daily-vacuum', '0 4 * * *', $
    CALL maintenance_vacuum_analyze();
$);
*/


-- ============================================
-- DOCUMENTATION FINALE
-- ============================================

COMMENT ON DATABASE postgres IS 'KravStats - Application de gestion de présences sportives multi-tenant';

-- Documentation des conventions
/*
CONVENTIONS DE NOMMAGE:
- Tables: pluriel, snake_case (ex: users, courses, attendances)
- Colonnes: snake_case (ex: first_name, created_at)
- Index: idx_tablename_columns (ex: idx_users_email_org)
- Contraintes: check_tablename_description (ex: check_course_max_duration)
- Fonctions: verbe_nom (ex: calculate_attendance_rate)
- Vues matérialisées: mv_description (ex: mv_member_stats)
- Triggers: nom_action (ex: update_users_updated_at)

TYPES DE DONNÉES:
- ID: UUID (sécurité, distribution)
- Dates: TIMESTAMP WITH TIME ZONE (internationalisation)
- Textes courts: VARCHAR avec limite
- Textes longs: TEXT
- Booléens: BOOLEAN (jamais NULL si logique binaire)
- Montants: INTEGER en centimes (éviter DECIMAL pour les montants)
- Données flexibles: JSONB (indexable avec GIN)

SÉCURITÉ:
- Row Level Security (RLS) activé sur toutes les tables multi-tenant
- Soft delete (deleted_at) pour traçabilité
- Audit logs pour actions critiques
- Contraintes CHECK pour validation côté DB
- SECURITY DEFINER pour fonctions sensibles

PERFORMANCE:
- Index partiels (WHERE) pour requêtes fréquentes
- Index composites pour requêtes complexes
- Vues matérialisées pour agrégations coûteuses
- Index GIN pour JSONB
- Contraintes de clés étrangères avec ON DELETE CASCADE/SET NULL

MAINTENANCE:
- Vacuum automatique (configurer autovacuum)
- Refresh vues matérialisées quotidien
- Nettoyage logs > 1 an
- Monitoring taille tables/index
- Backup quotidien (pg_dump ou solution cloud)

SCALABILITÉ:
- Partitionnement par date pour audit_logs si > 10M lignes
- Connection pooling (PgBouncer) recommandé
- Read replicas pour reporting (PostgreSQL streaming replication)
- Sharding par organization_id si > 1000 tenants
*/


-- ============================================
-- FIN DU SCHÉMA
-- ============================================

-- Afficher un résumé
DO $
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Schéma de base de données créé avec succès';
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Tables créées: %', (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_type = 'BASE TABLE');
    RAISE NOTICE 'Index créés: %', (SELECT COUNT(*) FROM pg_indexes WHERE schemaname = 'public');
    RAISE NOTICE 'Fonctions créées: %', (SELECT COUNT(*) FROM pg_proc WHERE pronamespace = 'public'::regnamespace);
    RAISE NOTICE 'Triggers créés: %', (SELECT COUNT(*) FROM pg_trigger WHERE tgrelid IN (SELECT oid FROM pg_class WHERE relnamespace = 'public'::regnamespace));
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Prochaines étapes:';
    RAISE NOTICE '1. Configurer les variables d''environnement';
    RAISE NOTICE '2. Créer les rôles app_user et app_readonly';
    RAISE NOTICE '3. Configurer pg_cron ou cron système pour maintenance';
    RAISE NOTICE '4. Configurer les backups automatiques';
    RAISE NOTICE '5. Tester les fonctions avec données de test';
    RAISE NOTICE '========================================';
END $;),
    
    -- Contact
    email VARCHAR(255) CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}-- ============================================
-- SCHÉMA DE BASE DE DONNÉES - KRAVSTATS
-- PostgreSQL 15+
-- Multi-tenant avec Row Level Security
-- ============================================

-- Extensions nécessaires
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ============================================
-- TABLE: organizations (Clubs/Tenants)
-- ============================================
CREATE TABLE organizations (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    
    -- Identité
    name VARCHAR(255) NOT NULL CHECK (char_length(name) >= 2),
    slug VARCHAR(100) UNIQUE NOT NULL CHECK (slug ~ '^[a-z0-9-]+$'),
    
    -- Contact
    email VARCHAR(255) CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}$'),
    phone VARCHAR(20),
    address TEXT,
    
    -- Branding
    logo_url VARCHAR(500),
    
    -- Configuration (JSONB pour flexibilité)
    settings JSONB NOT NULL DEFAULT '{
        "lock_attendance_by_coach": true,
        "default_capacity": 15,
        "season_start_month": 9,
        "timezone": "Europe/Paris"
    }'::jsonb,
    
    -- Abonnement
    subscription_status VARCHAR(20) NOT NULL DEFAULT 'trial' 
        CHECK (subscription_status IN ('trial', 'active', 'past_due', 'canceled', 'suspended')),
    subscription_plan VARCHAR(20) DEFAULT 'free'
        CHECK (subscription_plan IN ('free', 'pro', 'premium')),
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index
CREATE INDEX idx_organizations_slug ON organizations(slug) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_subscription_status ON organizations(subscription_status) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_trial_ends ON organizations(trial_ends_at) WHERE trial_ends_at IS NOT NULL;

-- Trigger pour updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_organizations_updated_at
    BEFORE UPDATE ON organizations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE organizations IS 'Clubs/Associations (tenants multi-tenant)';
COMMENT ON COLUMN organizations.settings IS 'Configuration JSON: lock_attendance_by_coach, default_capacity, etc.';


-- ============================================
-- TABLE: users (Tous les utilisateurs)
-- ============================================
CREATE TABLE users (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Authentification
    email VARCHAR(255) NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}$'),
    password_hash VARCHAR(255) NOT NULL,
    
    -- Identité
    first_name VARCHAR(100) NOT NULL CHECK (char_length(first_name) >= 1),
    last_name VARCHAR(100) NOT NULL CHECK (char_length(last_name) >= 1),
    phone VARCHAR(20),
    date_of_birth DATE CHECK (date_of_birth < CURRENT_DATE),
    
    -- Rôle et statut
    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'coach', 'member')),
    status VARCHAR(20) NOT NULL DEFAULT 'active' 
        CHECK (status IN ('active', 'inactive', 'suspended')),
    
    -- Dates importantes
    join_date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Métadonnées flexibles (ceintures, certificat médical, etc.)
    metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Sécurité
    email_verified BOOLEAN NOT NULL DEFAULT FALSE,
    last_login_at TIMESTAMP WITH TIME ZONE,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Constraints
    CONSTRAINT users_email_org_unique UNIQUE (email, organization_id)
);

-- Index optimisés
CREATE UNIQUE INDEX idx_users_email_org ON users(email, organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_organization_id ON users(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_role ON users(organization_id, role) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_status ON users(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_password_reset ON users(password_reset_token) WHERE password_reset_token IS NOT NULL;
CREATE INDEX idx_users_metadata_gin ON users USING gin(metadata jsonb_path_ops);

-- Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY users_isolation ON users
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE users IS 'Tous les utilisateurs (admins, coachs, adhérents)';
COMMENT ON COLUMN users.metadata IS 'Données flexibles: belt_level, medical_cert, preferences, etc.';
COMMENT ON COLUMN users.password_hash IS 'Hash bcrypt du mot de passe (coût 12)';


-- ============================================
-- TABLE: courses (Cours ponctuels et récurrents)
-- ============================================
CREATE TABLE courses (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Informations de base
    title VARCHAR(255) NOT NULL CHECK (char_length(title) >= 2),
    description TEXT,
    course_type VARCHAR(50),
    
    -- Horaires
    start_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    end_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    CHECK (end_datetime > start_datetime),
    
    -- Lieu
    location VARCHAR(255),
    
    -- Coach
    coach_id UUID REFERENCES users(id) ON DELETE SET NULL,
    
    -- Capacité
    max_capacity INTEGER CHECK (max_capacity > 0 OR max_capacity IS NULL),
    
    -- Récurrence
    is_recurring BOOLEAN NOT NULL DEFAULT FALSE,
    recurrence_rule JSONB CHECK (
        recurrence_rule IS NULL OR 
        (recurrence_rule ? 'frequency' AND recurrence_rule ? 'day_of_week')
    ),
    parent_recurrence_id UUID REFERENCES courses(id) ON DELETE SET NULL,
    
    -- Statut
    status VARCHAR(20) NOT NULL DEFAULT 'scheduled'
        CHECK (status IN ('scheduled', 'ongoing', 'completed', 'cancelled')),
    cancellation_reason TEXT,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index haute performance
CREATE INDEX idx_courses_organization_id ON courses(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_start_datetime ON courses(organization_id, start_datetime DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_coach_id ON courses(coach_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_status ON courses(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_parent_recurrence ON courses(parent_recurrence_id) WHERE parent_recurrence_id IS NOT NULL;
CREATE INDEX idx_courses_date_range ON courses(organization_id, start_datetime, end_datetime) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_recurrence_gin ON courses USING gin(recurrence_rule jsonb_path_ops) WHERE recurrence_rule IS NOT NULL;

-- Index pour recherches temporelles optimisées
CREATE INDEX idx_courses_upcoming ON courses(organization_id, start_datetime) 
    WHERE status = 'scheduled' AND deleted_at IS NULL;
CREATE INDEX idx_courses_past ON courses(organization_id, start_datetime DESC) 
    WHERE status = 'completed' AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE courses ENABLE ROW LEVEL SECURITY;

CREATE POLICY courses_isolation ON courses
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_courses_updated_at
    BEFORE UPDATE ON courses
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE courses IS 'Cours (ponctuels et récurrents avec occurrences)';
COMMENT ON COLUMN courses.recurrence_rule IS 'Règle de récurrence JSON: {frequency: "weekly", day_of_week: 1, end_date: "2026-06-30"}';
COMMENT ON COLUMN courses.parent_recurrence_id IS 'Lien vers le cours parent si occurrence de récurrence';


-- ============================================
-- TABLE: attendances (Présences et intentions)
-- ============================================
CREATE TABLE attendances (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    course_id UUID NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Intention (avant le cours)
    intention VARCHAR(20) CHECK (intention IN ('will_attend', 'will_not_attend') OR intention IS NULL),
    intention_at TIMESTAMP WITH TIME ZONE,
    
    -- Présence effective (pendant/après le cours)
    actual_attendance BOOLEAN,
    actual_attendance_at TIMESTAMP WITH TIME ZONE,
    
    -- Traçabilité
    marked_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    marked_by_role VARCHAR(20) CHECK (marked_by_role IN ('admin', 'coach', 'member') OR marked_by_role IS NULL),
    is_locked BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Notes
    notes TEXT,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contrainte unicité
    CONSTRAINT attendances_course_user_unique UNIQUE (course_id, user_id)
);

-- Index critiques pour performance
CREATE UNIQUE INDEX idx_attendances_course_user ON attendances(course_id, user_id);
CREATE INDEX idx_attendances_organization_id ON attendances(organization_id);
CREATE INDEX idx_attendances_user_id ON attendances(user_id);
CREATE INDEX idx_attendances_course_id ON attendances(course_id);

-- Index pour statistiques optimisées
CREATE INDEX idx_attendances_actual ON attendances(organization_id, user_id, actual_attendance) 
    WHERE actual_attendance IS NOT NULL;
CREATE INDEX idx_attendances_intention ON attendances(organization_id, course_id, intention) 
    WHERE intention IS NOT NULL;
CREATE INDEX idx_attendances_user_actual_date ON attendances(user_id, actual_attendance_at) 
    WHERE actual_attendance = TRUE;

-- Index composite pour requêtes fréquentes
CREATE INDEX idx_attendances_stats ON attendances(organization_id, user_id, actual_attendance, actual_attendance_at)
    WHERE actual_attendance IS NOT NULL;

-- Row Level Security
ALTER TABLE attendances ENABLE ROW LEVEL SECURITY;

CREATE POLICY attendances_isolation ON attendances
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_attendances_updated_at
    BEFORE UPDATE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE attendances IS 'Intentions et présences effectives aux cours';
COMMENT ON COLUMN attendances.intention IS 'Déclaration avant cours: will_attend ou will_not_attend';
COMMENT ON COLUMN attendances.actual_attendance IS 'Présence réelle: true = présent, false = absent, null = non encore marqué';
COMMENT ON COLUMN attendances.is_locked IS 'Verrouillage selon paramètre organisation';


-- ============================================
-- TABLE: subscriptions (Abonnements Stripe)
-- ============================================
CREATE TABLE subscriptions (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL UNIQUE REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Stripe
    stripe_customer_id VARCHAR(255) UNIQUE,
    stripe_subscription_id VARCHAR(255) UNIQUE,
    stripe_payment_method_id VARCHAR(255),
    
    -- Plan
    plan VARCHAR(20) NOT NULL CHECK (plan IN ('free', 'pro', 'premium')),
    status VARCHAR(20) NOT NULL 
        CHECK (status IN ('trialing', 'active', 'past_due', 'canceled', 'unpaid', 'incomplete')),
    
    -- Limites
    max_members INTEGER,
    features JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Dates
    current_period_start TIMESTAMP WITH TIME ZONE,
    current_period_end TIMESTAMP WITH TIME ZONE,
    trial_end TIMESTAMP WITH TIME ZONE,
    canceled_at TIMESTAMP WITH TIME ZONE,
    ended_at TIMESTAMP WITH TIME ZONE,
    
    -- Facturation
    amount_cents INTEGER CHECK (amount_cents >= 0),
    currency VARCHAR(3) NOT NULL DEFAULT 'EUR',
    interval VARCHAR(20) CHECK (interval IN ('month', 'year')),
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
CREATE INDEX idx_subscriptions_stripe_customer ON subscriptions(stripe_customer_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
CREATE INDEX idx_subscriptions_trial_end ON subscriptions(trial_end) WHERE trial_end IS NOT NULL;

-- Trigger
CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE subscriptions IS 'Abonnements et facturation Stripe';
COMMENT ON COLUMN subscriptions.features IS 'Fonctionnalités actives selon plan';


-- ============================================
-- TABLE: custom_fields (Champs personnalisés)
-- ============================================
CREATE TABLE custom_fields (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Définition
    field_name VARCHAR(100) NOT NULL,
    field_key VARCHAR(50) NOT NULL CHECK (field_key ~ '^[a-z_]+$'),
    field_type VARCHAR(20) NOT NULL 
        CHECK (field_type IN ('text', 'number', 'date', 'boolean', 'select', 'multi_select')),
    field_options JSONB DEFAULT '{}'::jsonb,
    
    -- Comportement
    is_required BOOLEAN NOT NULL DEFAULT FALSE,
    show_in_stats BOOLEAN NOT NULL DEFAULT FALSE,
    display_order INTEGER NOT NULL DEFAULT 0,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Contrainte unicité
    CONSTRAINT custom_fields_org_key_unique UNIQUE (organization_id, field_key)
);

-- Index
CREATE INDEX idx_custom_fields_organization ON custom_fields(organization_id, display_order) 
    WHERE deleted_at IS NULL;
CREATE INDEX idx_custom_fields_stats ON custom_fields(organization_id) 
    WHERE show_in_stats = TRUE AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE custom_fields ENABLE ROW LEVEL SECURITY;

CREATE POLICY custom_fields_isolation ON custom_fields
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_custom_fields_updated_at
    BEFORE UPDATE ON custom_fields
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE custom_fields IS 'Définition des champs personnalisés par organisation';
COMMENT ON COLUMN custom_fields.field_options IS 'Options JSON: {values: ["Option1", "Option2"]} pour select';


-- ============================================
-- TABLE: audit_logs (Traçabilité)
-- ============================================
CREATE TABLE audit_logs (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Qui
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    user_email VARCHAR(255),
    user_role VARCHAR(20),
    
    -- Quoi
    action VARCHAR(100) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID,
    
    -- Détails
    changes JSONB DEFAULT '{}'::jsonb,
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contexte
    ip_address INET,
    user_agent TEXT,
    
    -- Quand
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index pour requêtes fréquentes
CREATE INDEX idx_audit_logs_organization ON audit_logs(organization_id, created_at DESC);
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_entity ON audit_logs(entity_type, entity_id);
CREATE INDEX idx_audit_logs_created ON audit_logs(created_at DESC);

-- Partitionnement par date (recommandé si gros volume)
-- CREATE TABLE audit_logs_2025_10 PARTITION OF audit_logs
--     FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');

-- Row Level Security
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY audit_logs_isolation ON audit_logs
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Commentaires
COMMENT ON TABLE audit_logs IS 'Logs de toutes les actions utilisateurs (traçabilité complète)';
COMMENT ON COLUMN audit_logs.changes IS 'Changements JSON: {before: {...}, after: {...}}';


-- ============================================
-- VUES MATÉRIALISÉES (Performance)
-- ============================================

-- Vue: Statistiques adhérents pré-calculées
CREATE MATERIALIZED VIEW mv_member_stats AS
SELECT 
    u.id AS user_id,
    u.organization_id,
    u.first_name,
    u.last_name,
    COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled') AS available_courses,
    ROUND(
        (COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE)::numeric / 
        NULLIF(COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled'), 0)) * 100, 
        2
    ) AS attendance_rate,
    MAX(a.actual_attendance_at) AS last_attendance_date,
    CURRENT_DATE - MAX(a.actual_attendance_at)::date AS days_since_last_attendance
FROM users u
LEFT JOIN attendances a ON u.id = a.user_id
LEFT JOIN courses c ON a.course_id = c.id
WHERE u.deleted_at IS NULL 
    AND u.role = 'member'
    AND c.start_datetime >= CURRENT_DATE - INTERVAL '3 months'
GROUP BY u.id, u.organization_id, u.first_name, u.last_name;

-- Index sur vue matérialisée
CREATE UNIQUE INDEX idx_mv_member_stats_user ON mv_member_stats(user_id);
CREATE INDEX idx_mv_member_stats_org ON mv_member_stats(organization_id);
CREATE INDEX idx_mv_member_stats_rate ON mv_member_stats(organization_id, attendance_rate DESC);

-- Commentaire
COMMENT ON MATERIALIZED VIEW mv_member_stats IS 'Stats adhérents pré-calculées (refresh quotidien recommandé)';

-- Fonction de refresh automatique (à scheduler)
CREATE OR REPLACE FUNCTION refresh_member_stats()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_stats;
END;
$$ LANGUAGE plpgsql;


-- ============================================
-- FONCTIONS UTILITAIRES
-- ============================================

-- Fonction: Définir le tenant courant (pour RLS)
CREATE OR REPLACE FUNCTION set_current_tenant(tenant_id UUID)
RETURNS void AS $$
BEGIN
    PERFORM set_config('app.current_tenant', tenant_id::text, false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION set_current_tenant IS 'Définit le tenant courant pour Row Level Security';


-- Fonction: Calculer le taux de présence d'un adhérent
CREATE OR REPLACE FUNCTION calculate_attendance_rate(
    p_user_id UUID,
    p_start_date TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_end_date TIMESTAMP WITH TIME ZONE DEFAULT NULL
)
RETURNS NUMERIC AS $$
DECLARE
    v_attendances INTEGER;
    v_available_courses INTEGER;
BEGIN
    -- Compte les présences effectives
    SELECT COUNT(*) INTO v_attendances
    FROM attendances a
    INNER JOIN courses c ON a.course_id = c.id
    WHERE a.user_id = p_user_id
        AND a.actual_attendance = TRUE
        AND (p_start_date IS NULL OR c.start_datetime >= p_start_date)
        AND (p_end_date IS NULL OR c.start_datetime <= p_end_date);
    
    -- Compte les cours disponibles (non annulés)
    SELECT COUNT(DISTINCT c.id) INTO v_available_courses
    FROM courses c
    WHERE c.organization_id = (SELECT organization_id FROM users WHERE id = p_user_id)
        AND c.status != 'cancelled'
        AND (p_start_date IS NULL OR c.start_datetime >= p_start_date)
        AND (p_end_date IS NULL OR c.start_datetime <= p_end_date);
    
    -- Calcul du taux
    IF v_available_courses = 0 THEN
        RETURN 0;
    END IF;
    
    RETURN ROUND((v_attendances::numeric / v_available_courses) * 100, 2);
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION calculate_attendance_rate IS 'Calcule le taux de présence d''un adhérent sur une période';


-- Fonction: Détecter les adhérents à risque d'abandon
CREATE OR REPLACE FUNCTION detect_at_risk_members(
    p_organization_id UUID,
    p_days_threshold INTEGER DEFAULT 21
)
RETURNS TABLE (
    user_id UUID,
    user_name TEXT,
    days_absent INTEGER,
    previous_rate NUMERIC,
    risk_level TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.id,
        u.first_name || ' ' || u.last_name,
        CURRENT_DATE - MAX(a.actual_attendance_at)::date,
        calculate_attendance_rate(u.id, CURRENT_DATE - INTERVAL '3 months', CURRENT_DATE - INTERVAL '1 month'),
        CASE 
            WHEN CURRENT_DATE - MAX(a.actual_attendance_at)::date >= 30 THEN 'critical'
            WHEN CURRENT_DATE - MAX(a.actual_attendance_at)::date >= p_days_threshold THEN 'warning'
            ELSE 'normal'
        END
    FROM users u
    LEFT JOIN attendances a ON u.id = a.user_id AND a.actual_attendance = TRUE
    WHERE u.organization_id = p_organization_id
        AND u.role = 'member'
        AND u.status = 'active'
        AND u.deleted_at IS NULL
    GROUP BY u.id, u.first_name, u.last_name
    HAVING MAX(a.actual_attendance_at) IS NOT NULL
        AND CURRENT_DATE - MAX(a.actual_attendance_at)::date >= p_days_threshold
    ORDER BY CURRENT_DATE - MAX(a.actual_attendance_at)::date DESC;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION detect_at_risk_members IS 'Détecte les adhérents absents depuis X jours (risque abandon)';


-- ============================================
-- TRIGGERS AVANCÉS
-- ============================================

-- Trigger: Auto-update subscription_status dans organizations
CREATE OR REPLACE FUNCTION sync_subscription_status()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE organizations 
    SET subscription_status = NEW.status
    WHERE id = NEW.organization_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_subscription_to_org
    AFTER INSERT OR UPDATE OF status ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION sync_subscription_status();


-- Trigger: Audit automatique sur modifications importantes
CREATE OR REPLACE FUNCTION log_important_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_logs (
            organization_id,
            user_id,
            action,
            entity_type,
            entity_id,
            changes
        ) VALUES (
            NEW.organization_id,
            current_setting('app.current_user_id', true)::uuid,
            TG_TABLE_NAME || '.updated',
            TG_TABLE_NAME,
            NEW.id,
            jsonb_build_object('before', to_jsonb(OLD), 'after', to_jsonb(NEW))
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_logs (
            organization_id,
            user_id,
            action,
            entity_type,
            entity_id,
            changes
        ) VALUES (
            OLD.organization_id,
            current_setting('app.current_user_id', true)::uuid,
            TG_TABLE_NAME || '.deleted',
            TG_TABLE_NAME,
            OLD.id,
            jsonb_build_object('before', to_jsonb(OLD))
        );
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Appliquer l'audit sur les tables critiques
CREATE TRIGGER audit_courses_changes
    AFTER UPDATE OR DELETE ON courses
    FOR EACH ROW
    EXECUTE FUNCTION log_important_changes();

CREATE TRIGGER audit_attendances_changes
    AFTER UPDATE OR DELETE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION log_important_changes();


-- ============================================
-- CONTRAINTES D'INTÉGRITÉ AVANCÉES
-- ============================================

-- Vérifier que le coach appartient à l'organisation
ALTER TABLE courses ADD CONSTRAINT check_coach_organization
    CHECK (
        coach_id IS NULL OR 
        EXISTS (
            SELECT 1 FROM users 
            WHERE id = coach_id 
            AND organization_id = courses.organization_id
            AND role IN ('coach', 'admin')
        )
    );

-- Vérifier cohérence des dates de récurrence
ALTER TABLE courses ADD CONSTRAINT check_recurrence_dates
    CHECK (
        NOT is_recurring OR 
        (recurrence_rule IS NOT NULL)
    );


-- ============================================
-- GRANTS ET SÉCURITÉ
-- ============================================

-- Rôle application (utilisé par le backend)
CREATE ROLE app_user WITH LOGIN PASSWORD 'change_me_in_production';

-- Permissions strictes
GRANT CONNECT ON DATABASE postgres TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO app_user;

-- Lecture seule pour les rapports
CREATE ROLE app_readonly WITH LOGIN PASSWORD 'change_me_readonly';
GRANT CONNECT ON DATABASE postgres TO app_readonly;
GRANT USAGE ON SCHEMA public TO app_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_readonly;


-- ============================================
-- DONNÉES DE TEST (Optionnel)
-- ============================================

-- Insertion organisation de test
INSERT INTO organizations (id, name, slug, email, subscription_plan, subscription_status)
VALUES (
    'a0000000-0000-0000-0000-000000000001',
    'Krav Maga Lyon Centre',
    'krav-maga-lyon-centre',
    'contact@kravlyon.fr',
    'pro',
    'active'
);

-- Insertion utilisateurs de test
INSERT INTO users (organization_id, email, password_hash, first_name, last_name, role)
VALUES 
    ('a0000000-0000-0000-0000-000000000001', 'admin@kravlyon.fr', '$2b$12$dummy_hash', 'Sophie', 'Bernard', 'admin'),
    ('a0000000-0000-0000-0000-000000000001', 'marc@kravlyon.fr', '$2b$12$dummy_hash', 'Marc', 'Petit', 'coach'),
    ('a0000000-0000-0000-0000-000000000001', 'lisa@email.com', '$2b$12$dummy_hash', 'Lisa', 'Martin', 'member');


-- ============================================
-- MAINTENANCE ET MONITORING
-- ============================================

-- ============================================
-- MAINTENANCE ET MONITORING
-- ============================================

-- Vue pour monitoring des performances
CREATE VIEW v_table_sizes AS
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) AS indexes_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

COMMENT ON VIEW v_table_sizes IS 'Taille des tables et indexes pour monitoring';


-- Vue pour monitoring des index inutilisés
CREATE VIEW v_unused_indexes AS
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
    AND indexrelname NOT LIKE 'pg_toast%'
    AND schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;

COMMENT ON VIEW v_unused_indexes IS 'Index jamais utilisés (candidats pour suppression)';


-- Vue pour monitoring des connexions actives
CREATE VIEW v_active_connections AS
SELECT 
    datname,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change,
    wait_event_type,
    wait_event,
    LEFT(query, 100) AS query_preview
FROM pg_stat_activity
WHERE datname = current_database()
    AND pid != pg_backend_pid()
ORDER BY query_start;

COMMENT ON VIEW v_active_connections IS 'Connexions actives à la base de données';


-- Vue pour statistiques par organisation
CREATE VIEW v_organization_stats AS
SELECT 
    o.id,
    o.name,
    o.subscription_plan,
    COUNT(DISTINCT u.id) FILTER (WHERE u.role = 'member' AND u.deleted_at IS NULL) AS total_members,
    COUNT(DISTINCT u.id) FILTER (WHERE u.role = 'coach' AND u.deleted_at IS NULL) AS total_coaches,
    COUNT(DISTINCT c.id) FILTER (WHERE c.deleted_at IS NULL) AS total_courses,
    COUNT(DISTINCT a.id) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    ROUND(
        AVG(
            (SELECT calculate_attendance_rate(u2.id, CURRENT_DATE - INTERVAL '30 days', CURRENT_DATE)
             FROM users u2 
             WHERE u2.organization_id = o.id AND u2.role = 'member' AND u2.deleted_at IS NULL)
        ), 2
    ) AS avg_attendance_rate_30d
FROM organizations o
LEFT JOIN users u ON o.id = u.organization_id
LEFT JOIN courses c ON o.id = c.organization_id
LEFT JOIN attendances a ON o.id = a.organization_id
WHERE o.deleted_at IS NULL
GROUP BY o.id, o.name, o.subscription_plan;

COMMENT ON VIEW v_organization_stats IS 'Statistiques agrégées par organisation';


-- ============================================
-- PROCÉDURES DE MAINTENANCE
-- ============================================

-- Procédure: Nettoyage des données obsolètes
CREATE OR REPLACE PROCEDURE cleanup_old_data(
    p_audit_logs_retention_days INTEGER DEFAULT 365,
    p_deleted_records_retention_days INTEGER DEFAULT 90
)
LANGUAGE plpgsql
AS $
BEGIN
    -- Supprimer les vieux logs d'audit
    DELETE FROM audit_logs 
    WHERE created_at < CURRENT_DATE - (p_audit_logs_retention_days || ' days')::INTERVAL;
    
    RAISE NOTICE 'Audit logs nettoyés: % lignes supprimées', 
        (SELECT count(*) FROM audit_logs WHERE created_at < CURRENT_DATE - (p_audit_logs_retention_days || ' days')::INTERVAL);
    
    -- Supprimer définitivement les enregistrements soft-deleted anciens
    DELETE FROM users 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    DELETE FROM courses 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    DELETE FROM organizations 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    RAISE NOTICE 'Nettoyage terminé';
END;
$;

COMMENT ON PROCEDURE cleanup_old_data IS 'Nettoyage automatique des données obsolètes (à scheduler)';


-- Procédure: Vacuum et analyse automatiques
CREATE OR REPLACE PROCEDURE maintenance_vacuum_analyze()
LANGUAGE plpgsql
AS $
BEGIN
    VACUUM ANALYZE organizations;
    VACUUM ANALYZE users;
    VACUUM ANALYZE courses;
    VACUUM ANALYZE attendances;
    VACUUM ANALYZE subscriptions;
    VACUUM ANALYZE custom_fields;
    VACUUM ANALYZE audit_logs;
    
    RAISE NOTICE 'Vacuum et analyse terminés';
END;
$;

COMMENT ON PROCEDURE maintenance_vacuum_analyze IS 'Vacuum et analyse des tables principales (à scheduler quotidiennement)';


-- Procédure: Refresh des vues matérialisées
CREATE OR REPLACE PROCEDURE refresh_all_materialized_views()
LANGUAGE plpgsql
AS $
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_stats;
    RAISE NOTICE 'Vues matérialisées rafraîchies';
END;
$;

COMMENT ON PROCEDURE refresh_all_materialized_views IS 'Rafraîchissement de toutes les vues matérialisées (à scheduler quotidiennement)';


-- ============================================
-- BACKUP ET RESTORE
-- ============================================

-- Fonction: Export des données d'une organisation (RGPD)
CREATE OR REPLACE FUNCTION export_organization_data(p_organization_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $
DECLARE
    v_data JSONB;
BEGIN
    SELECT jsonb_build_object(
        'organization', (SELECT row_to_json(o.*) FROM organizations o WHERE id = p_organization_id),
        'users', (SELECT jsonb_agg(row_to_json(u.*)) FROM users u WHERE organization_id = p_organization_id AND deleted_at IS NULL),
        'courses', (SELECT jsonb_agg(row_to_json(c.*)) FROM courses c WHERE organization_id = p_organization_id AND deleted_at IS NULL),
        'attendances', (SELECT jsonb_agg(row_to_json(a.*)) FROM attendances a WHERE organization_id = p_organization_id),
        'custom_fields', (SELECT jsonb_agg(row_to_json(cf.*)) FROM custom_fields cf WHERE organization_id = p_organization_id AND deleted_at IS NULL)
    ) INTO v_data;
    
    RETURN v_data;
END;
$;

COMMENT ON FUNCTION export_organization_data IS 'Export complet des données d''une organisation (conformité RGPD)';


-- Fonction: Anonymisation d'un utilisateur (RGPD - droit à l'oubli)
CREATE OR REPLACE FUNCTION anonymize_user(p_user_id UUID)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $
BEGIN
    UPDATE users
    SET 
        email = 'deleted_' || id || '@anonymized.local',
        first_name = 'Utilisateur',
        last_name = '[Supprimé]',
        phone = NULL,
        date_of_birth = NULL,
        metadata = '{}'::jsonb,
        password_hash = 'ANONYMIZED',
        deleted_at = CURRENT_TIMESTAMP
    WHERE id = p_user_id;
    
    -- Log de l'action
    INSERT INTO audit_logs (
        organization_id,
        user_id,
        action,
        entity_type,
        entity_id,
        metadata
    ) VALUES (
        (SELECT organization_id FROM users WHERE id = p_user_id),
        p_user_id,
        'user.anonymized',
        'users',
        p_user_id,
        jsonb_build_object('anonymized_at', CURRENT_TIMESTAMP, 'reason', 'RGPD_right_to_be_forgotten')
    );
    
    RAISE NOTICE 'Utilisateur % anonymisé', p_user_id;
END;
$;

COMMENT ON FUNCTION anonymize_user IS 'Anonymisation d''un utilisateur (RGPD - droit à l''oubli)';


-- ============================================
-- INDEXES PARTIELS AVANCÉS (Optimisation)
-- ============================================

-- Index pour les cours à venir uniquement (requête très fréquente)
CREATE INDEX idx_courses_upcoming_detailed ON courses(organization_id, start_datetime, status)
    WHERE start_datetime > CURRENT_TIMESTAMP 
        AND status = 'scheduled' 
        AND deleted_at IS NULL;

-- Index pour les adhérents actifs récents
CREATE INDEX idx_users_active_recent ON users(organization_id, last_login_at DESC)
    WHERE status = 'active' 
        AND deleted_at IS NULL
        AND last_login_at > CURRENT_TIMESTAMP - INTERVAL '30 days';

-- Index pour présences du mois en cours (statistiques temps réel)
CREATE INDEX idx_attendances_current_month ON attendances(organization_id, user_id, actual_attendance)
    WHERE actual_attendance_at >= date_trunc('month', CURRENT_DATE)
        AND actual_attendance IS NOT NULL;


-- ============================================
-- POLICIES RLS AVANCÉES (Sécurité fine)
-- ============================================

-- Policy: Les coachs ne voient que leurs cours
CREATE POLICY coaches_own_courses ON courses
    FOR SELECT
    USING (
        organization_id = current_setting('app.current_tenant', true)::uuid
        AND (
            coach_id = current_setting('app.current_user_id', true)::uuid
            OR EXISTS (
                SELECT 1 FROM users 
                WHERE id = current_setting('app.current_user_id', true)::uuid 
                AND role IN ('admin')
            )
        )
    );

-- Policy: Les adhérents ne voient que leurs propres présences détaillées
CREATE POLICY members_own_attendances ON attendances
    FOR SELECT
    USING (
        organization_id = current_setting('app.current_tenant', true)::uuid
        AND (
            user_id = current_setting('app.current_user_id', true)::uuid
            OR EXISTS (
                SELECT 1 FROM users 
                WHERE id = current_setting('app.current_user_id', true)::uuid 
                AND role IN ('admin', 'coach')
            )
        )
    );


-- ============================================
-- CONTRAINTES DE VALIDATION MÉTIER
-- ============================================

-- Vérifier qu'un cours ne dépasse pas 24h
ALTER TABLE courses ADD CONSTRAINT check_course_max_duration
    CHECK (end_datetime - start_datetime <= INTERVAL '24 hours');

-- Vérifier qu'on ne peut pas marquer présent à un cours dans le futur
CREATE OR REPLACE FUNCTION check_attendance_not_future()
RETURNS TRIGGER AS $
BEGIN
    IF NEW.actual_attendance IS NOT NULL AND NEW.actual_attendance_at IS NOT NULL THEN
        IF NEW.actual_attendance_at > (SELECT end_datetime FROM courses WHERE id = NEW.course_id) + INTERVAL '2 hours' THEN
            RAISE EXCEPTION 'Impossible de marquer une présence plus de 2h après la fin du cours';
        END IF;
    END IF;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER validate_attendance_timing
    BEFORE INSERT OR UPDATE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION check_attendance_not_future();


-- ============================================
-- FONCTIONS D'AGRÉGATION PERSONNALISÉES
-- ============================================

-- Fonction: Statistiques complètes d'un adhérent
CREATE OR REPLACE FUNCTION get_member_complete_stats(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $
DECLARE
    v_stats JSONB;
BEGIN
    SELECT jsonb_build_object(
        'user_id', p_user_id,
        'total_courses_available', (
            SELECT COUNT(*) 
            FROM courses c
            WHERE c.organization_id = (SELECT organization_id FROM users WHERE id = p_user_id)
                AND c.status != 'cancelled'
                AND c.start_datetime >= (SELECT join_date FROM users WHERE id = p_user_id)
                AND c.deleted_at IS NULL
        ),
        'total_attendances', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'attendance_rate', calculate_attendance_rate(p_user_id),
        'attendance_rate_30d', calculate_attendance_rate(p_user_id, CURRENT_DATE - INTERVAL '30 days', CURRENT_DATE),
        'attendance_rate_90d', calculate_attendance_rate(p_user_id, CURRENT_DATE - INTERVAL '90 days', CURRENT_DATE),
        'last_attendance', (
            SELECT MAX(actual_attendance_at) 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'days_since_last_attendance', (
            SELECT CURRENT_DATE - MAX(actual_attendance_at)::date 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'current_streak', (
            -- Série de présences consécutives (simplifié)
            SELECT COUNT(*)
            FROM attendances a
            INNER JOIN courses c ON a.course_id = c.id
            WHERE a.user_id = p_user_id 
                AND a.actual_attendance = TRUE
                AND c.start_datetime >= CURRENT_DATE - INTERVAL '30 days'
        ),
        'total_intentions', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE user_id = p_user_id AND intention = 'will_attend'
        ),
        'intention_reliability', (
            -- Fiabilité des inscriptions
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE intention = 'will_attend' AND actual_attendance = TRUE)::numeric /
                NULLIF(COUNT(*) FILTER (WHERE intention = 'will_attend'), 0)) * 100, 2
            )
            FROM attendances
            WHERE user_id = p_user_id
        )
    ) INTO v_stats;
    
    RETURN v_stats;
END;
$;

COMMENT ON FUNCTION get_member_complete_stats IS 'Statistiques complètes d''un adhérent (toutes périodes)';


-- Fonction: Statistiques d'un cours
CREATE OR REPLACE FUNCTION get_course_stats(p_course_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $
DECLARE
    v_stats JSONB;
BEGIN
    SELECT jsonb_build_object(
        'course_id', p_course_id,
        'total_enrolled', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE course_id = p_course_id AND intention = 'will_attend'
        ),
        'total_attended', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE course_id = p_course_id AND actual_attendance = TRUE
        ),
        'occupancy_rate', (
            SELECT CASE 
                WHEN c.max_capacity IS NOT NULL THEN
                    ROUND((COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE)::numeric / c.max_capacity) * 100, 2)
                ELSE NULL
            END
            FROM courses c
            LEFT JOIN attendances a ON c.id = a.course_id
            WHERE c.id = p_course_id
            GROUP BY c.max_capacity
        ),
        'no_show_rate', (
            -- Taux de non-présentation (inscrits mais absents)
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE intention = 'will_attend' AND actual_attendance = FALSE)::numeric /
                NULLIF(COUNT(*) FILTER (WHERE intention = 'will_attend'), 0)) * 100, 2
            )
            FROM attendances
            WHERE course_id = p_course_id
        ),
        'walk_ins', (
            -- Présents non-inscrits
            SELECT COUNT(*)
            FROM attendances
            WHERE course_id = p_course_id 
                AND intention IS NULL 
                AND actual_attendance = TRUE
        )
    ) INTO v_stats;
    
    RETURN v_stats;
END;
$;

COMMENT ON FUNCTION get_course_stats IS 'Statistiques détaillées d''un cours';


-- ============================================
-- SCHEDULING (À configurer via pg_cron ou cron externe)
-- ============================================

-- Extension pg_cron (optionnelle, nécessite installation)
-- CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Exemples de tâches planifiées (à décommenter si pg_cron installé)
/*
-- Refresh des stats quotidien à 2h du matin
SELECT cron.schedule('refresh-stats', '0 2 * * *', $
    CALL refresh_all_materialized_views();
$);

-- Nettoyage hebdomadaire le dimanche à 3h
SELECT cron.schedule('cleanup-old-data', '0 3 * * 0', $
    CALL cleanup_old_data(365, 90);
$);

-- Vacuum quotidien à 4h
SELECT cron.schedule('daily-vacuum', '0 4 * * *', $
    CALL maintenance_vacuum_analyze();
$);
*/


-- ============================================
-- DOCUMENTATION FINALE
-- ============================================

COMMENT ON DATABASE postgres IS 'KravStats - Application de gestion de présences sportives multi-tenant';

-- Documentation des conventions
/*
CONVENTIONS DE NOMMAGE:
- Tables: pluriel, snake_case (ex: users, courses, attendances)
- Colonnes: snake_case (ex: first_name, created_at)
- Index: idx_tablename_columns (ex: idx_users_email_org)
- Contraintes: check_tablename_description (ex: check_course_max_duration)
- Fonctions: verbe_nom (ex: calculate_attendance_rate)
- Vues matérialisées: mv_description (ex: mv_member_stats)
- Triggers: nom_action (ex: update_users_updated_at)

TYPES DE DONNÉES:
- ID: UUID (sécurité, distribution)
- Dates: TIMESTAMP WITH TIME ZONE (internationalisation)
- Textes courts: VARCHAR avec limite
- Textes longs: TEXT
- Booléens: BOOLEAN (jamais NULL si logique binaire)
- Montants: INTEGER en centimes (éviter DECIMAL pour les montants)
- Données flexibles: JSONB (indexable avec GIN)

SÉCURITÉ:
- Row Level Security (RLS) activé sur toutes les tables multi-tenant
- Soft delete (deleted_at) pour traçabilité
- Audit logs pour actions critiques
- Contraintes CHECK pour validation côté DB
- SECURITY DEFINER pour fonctions sensibles

PERFORMANCE:
- Index partiels (WHERE) pour requêtes fréquentes
- Index composites pour requêtes complexes
- Vues matérialisées pour agrégations coûteuses
- Index GIN pour JSONB
- Contraintes de clés étrangères avec ON DELETE CASCADE/SET NULL

MAINTENANCE:
- Vacuum automatique (configurer autovacuum)
- Refresh vues matérialisées quotidien
- Nettoyage logs > 1 an
- Monitoring taille tables/index
- Backup quotidien (pg_dump ou solution cloud)

SCALABILITÉ:
- Partitionnement par date pour audit_logs si > 10M lignes
- Connection pooling (PgBouncer) recommandé
- Read replicas pour reporting (PostgreSQL streaming replication)
- Sharding par organization_id si > 1000 tenants
*/


-- ============================================
-- FIN DU SCHÉMA
-- ============================================

-- Afficher un résumé
DO $
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Schéma de base de données créé avec succès';
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Tables créées: %', (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_type = 'BASE TABLE');
    RAISE NOTICE 'Index créés: %', (SELECT COUNT(*) FROM pg_indexes WHERE schemaname = 'public');
    RAISE NOTICE 'Fonctions créées: %', (SELECT COUNT(*) FROM pg_proc WHERE pronamespace = 'public'::regnamespace);
    RAISE NOTICE 'Triggers créés: %', (SELECT COUNT(*) FROM pg_trigger WHERE tgrelid IN (SELECT oid FROM pg_class WHERE relnamespace = 'public'::regnamespace));
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Prochaines étapes:';
    RAISE NOTICE '1. Configurer les variables d''environnement';
    RAISE NOTICE '2. Créer les rôles app_user et app_readonly';
    RAISE NOTICE '3. Configurer pg_cron ou cron système pour maintenance';
    RAISE NOTICE '4. Configurer les backups automatiques';
    RAISE NOTICE '5. Tester les fonctions avec données de test';
    RAISE NOTICE '========================================';
END $;),
    phone VARCHAR(20),
    address TEXT,
    
    -- Branding
    logo_url VARCHAR(500),
    
    -- Configuration (JSONB pour flexibilité)
    settings JSONB NOT NULL DEFAULT '{
        "lock_attendance_by_coach": true,
        "default_capacity": 15,
        "season_start_month": 9,
        "timezone": "Europe/Paris"
    }'::jsonb,
    
    -- Abonnement
    subscription_status VARCHAR(20) NOT NULL DEFAULT 'trial' 
        CHECK (subscription_status IN ('trial', 'active', 'past_due', 'canceled', 'suspended')),
    subscription_plan VARCHAR(20) DEFAULT 'free'
        CHECK (subscription_plan IN ('free', 'pro', 'premium')),
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index
CREATE INDEX idx_organizations_slug ON organizations(slug) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_subscription_status ON organizations(subscription_status) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_trial_ends ON organizations(trial_ends_at) WHERE trial_ends_at IS NOT NULL;

-- Trigger pour updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER update_organizations_updated_at
    BEFORE UPDATE ON organizations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE organizations IS 'Clubs/Associations (tenants multi-tenant)';
COMMENT ON COLUMN organizations.settings IS 'Configuration JSON: lock_attendance_by_coach, default_capacity, etc.';


-- ============================================
-- TABLE: users (Tous les utilisateurs)
-- ============================================
CREATE TABLE users (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Authentification
    email VARCHAR(255) NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}-- ============================================
-- SCHÉMA DE BASE DE DONNÉES - KRAVSTATS
-- PostgreSQL 15+
-- Multi-tenant avec Row Level Security
-- ============================================

-- Extensions nécessaires
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ============================================
-- TABLE: organizations (Clubs/Tenants)
-- ============================================
CREATE TABLE organizations (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    
    -- Identité
    name VARCHAR(255) NOT NULL CHECK (char_length(name) >= 2),
    slug VARCHAR(100) UNIQUE NOT NULL CHECK (slug ~ '^[a-z0-9-]+$'),
    
    -- Contact
    email VARCHAR(255) CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}$'),
    phone VARCHAR(20),
    address TEXT,
    
    -- Branding
    logo_url VARCHAR(500),
    
    -- Configuration (JSONB pour flexibilité)
    settings JSONB NOT NULL DEFAULT '{
        "lock_attendance_by_coach": true,
        "default_capacity": 15,
        "season_start_month": 9,
        "timezone": "Europe/Paris"
    }'::jsonb,
    
    -- Abonnement
    subscription_status VARCHAR(20) NOT NULL DEFAULT 'trial' 
        CHECK (subscription_status IN ('trial', 'active', 'past_due', 'canceled', 'suspended')),
    subscription_plan VARCHAR(20) DEFAULT 'free'
        CHECK (subscription_plan IN ('free', 'pro', 'premium')),
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index
CREATE INDEX idx_organizations_slug ON organizations(slug) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_subscription_status ON organizations(subscription_status) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_trial_ends ON organizations(trial_ends_at) WHERE trial_ends_at IS NOT NULL;

-- Trigger pour updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_organizations_updated_at
    BEFORE UPDATE ON organizations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE organizations IS 'Clubs/Associations (tenants multi-tenant)';
COMMENT ON COLUMN organizations.settings IS 'Configuration JSON: lock_attendance_by_coach, default_capacity, etc.';


-- ============================================
-- TABLE: users (Tous les utilisateurs)
-- ============================================
CREATE TABLE users (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Authentification
    email VARCHAR(255) NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}$'),
    password_hash VARCHAR(255) NOT NULL,
    
    -- Identité
    first_name VARCHAR(100) NOT NULL CHECK (char_length(first_name) >= 1),
    last_name VARCHAR(100) NOT NULL CHECK (char_length(last_name) >= 1),
    phone VARCHAR(20),
    date_of_birth DATE CHECK (date_of_birth < CURRENT_DATE),
    
    -- Rôle et statut
    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'coach', 'member')),
    status VARCHAR(20) NOT NULL DEFAULT 'active' 
        CHECK (status IN ('active', 'inactive', 'suspended')),
    
    -- Dates importantes
    join_date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Métadonnées flexibles (ceintures, certificat médical, etc.)
    metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Sécurité
    email_verified BOOLEAN NOT NULL DEFAULT FALSE,
    last_login_at TIMESTAMP WITH TIME ZONE,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Constraints
    CONSTRAINT users_email_org_unique UNIQUE (email, organization_id)
);

-- Index optimisés
CREATE UNIQUE INDEX idx_users_email_org ON users(email, organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_organization_id ON users(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_role ON users(organization_id, role) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_status ON users(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_password_reset ON users(password_reset_token) WHERE password_reset_token IS NOT NULL;
CREATE INDEX idx_users_metadata_gin ON users USING gin(metadata jsonb_path_ops);

-- Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY users_isolation ON users
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE users IS 'Tous les utilisateurs (admins, coachs, adhérents)';
COMMENT ON COLUMN users.metadata IS 'Données flexibles: belt_level, medical_cert, preferences, etc.';
COMMENT ON COLUMN users.password_hash IS 'Hash bcrypt du mot de passe (coût 12)';


-- ============================================
-- TABLE: courses (Cours ponctuels et récurrents)
-- ============================================
CREATE TABLE courses (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Informations de base
    title VARCHAR(255) NOT NULL CHECK (char_length(title) >= 2),
    description TEXT,
    course_type VARCHAR(50),
    
    -- Horaires
    start_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    end_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    CHECK (end_datetime > start_datetime),
    
    -- Lieu
    location VARCHAR(255),
    
    -- Coach
    coach_id UUID REFERENCES users(id) ON DELETE SET NULL,
    
    -- Capacité
    max_capacity INTEGER CHECK (max_capacity > 0 OR max_capacity IS NULL),
    
    -- Récurrence
    is_recurring BOOLEAN NOT NULL DEFAULT FALSE,
    recurrence_rule JSONB CHECK (
        recurrence_rule IS NULL OR 
        (recurrence_rule ? 'frequency' AND recurrence_rule ? 'day_of_week')
    ),
    parent_recurrence_id UUID REFERENCES courses(id) ON DELETE SET NULL,
    
    -- Statut
    status VARCHAR(20) NOT NULL DEFAULT 'scheduled'
        CHECK (status IN ('scheduled', 'ongoing', 'completed', 'cancelled')),
    cancellation_reason TEXT,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index haute performance
CREATE INDEX idx_courses_organization_id ON courses(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_start_datetime ON courses(organization_id, start_datetime DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_coach_id ON courses(coach_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_status ON courses(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_parent_recurrence ON courses(parent_recurrence_id) WHERE parent_recurrence_id IS NOT NULL;
CREATE INDEX idx_courses_date_range ON courses(organization_id, start_datetime, end_datetime) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_recurrence_gin ON courses USING gin(recurrence_rule jsonb_path_ops) WHERE recurrence_rule IS NOT NULL;

-- Index pour recherches temporelles optimisées
CREATE INDEX idx_courses_upcoming ON courses(organization_id, start_datetime) 
    WHERE status = 'scheduled' AND deleted_at IS NULL;
CREATE INDEX idx_courses_past ON courses(organization_id, start_datetime DESC) 
    WHERE status = 'completed' AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE courses ENABLE ROW LEVEL SECURITY;

CREATE POLICY courses_isolation ON courses
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_courses_updated_at
    BEFORE UPDATE ON courses
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE courses IS 'Cours (ponctuels et récurrents avec occurrences)';
COMMENT ON COLUMN courses.recurrence_rule IS 'Règle de récurrence JSON: {frequency: "weekly", day_of_week: 1, end_date: "2026-06-30"}';
COMMENT ON COLUMN courses.parent_recurrence_id IS 'Lien vers le cours parent si occurrence de récurrence';


-- ============================================
-- TABLE: attendances (Présences et intentions)
-- ============================================
CREATE TABLE attendances (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    course_id UUID NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Intention (avant le cours)
    intention VARCHAR(20) CHECK (intention IN ('will_attend', 'will_not_attend') OR intention IS NULL),
    intention_at TIMESTAMP WITH TIME ZONE,
    
    -- Présence effective (pendant/après le cours)
    actual_attendance BOOLEAN,
    actual_attendance_at TIMESTAMP WITH TIME ZONE,
    
    -- Traçabilité
    marked_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    marked_by_role VARCHAR(20) CHECK (marked_by_role IN ('admin', 'coach', 'member') OR marked_by_role IS NULL),
    is_locked BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Notes
    notes TEXT,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contrainte unicité
    CONSTRAINT attendances_course_user_unique UNIQUE (course_id, user_id)
);

-- Index critiques pour performance
CREATE UNIQUE INDEX idx_attendances_course_user ON attendances(course_id, user_id);
CREATE INDEX idx_attendances_organization_id ON attendances(organization_id);
CREATE INDEX idx_attendances_user_id ON attendances(user_id);
CREATE INDEX idx_attendances_course_id ON attendances(course_id);

-- Index pour statistiques optimisées
CREATE INDEX idx_attendances_actual ON attendances(organization_id, user_id, actual_attendance) 
    WHERE actual_attendance IS NOT NULL;
CREATE INDEX idx_attendances_intention ON attendances(organization_id, course_id, intention) 
    WHERE intention IS NOT NULL;
CREATE INDEX idx_attendances_user_actual_date ON attendances(user_id, actual_attendance_at) 
    WHERE actual_attendance = TRUE;

-- Index composite pour requêtes fréquentes
CREATE INDEX idx_attendances_stats ON attendances(organization_id, user_id, actual_attendance, actual_attendance_at)
    WHERE actual_attendance IS NOT NULL;

-- Row Level Security
ALTER TABLE attendances ENABLE ROW LEVEL SECURITY;

CREATE POLICY attendances_isolation ON attendances
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_attendances_updated_at
    BEFORE UPDATE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE attendances IS 'Intentions et présences effectives aux cours';
COMMENT ON COLUMN attendances.intention IS 'Déclaration avant cours: will_attend ou will_not_attend';
COMMENT ON COLUMN attendances.actual_attendance IS 'Présence réelle: true = présent, false = absent, null = non encore marqué';
COMMENT ON COLUMN attendances.is_locked IS 'Verrouillage selon paramètre organisation';


-- ============================================
-- TABLE: subscriptions (Abonnements Stripe)
-- ============================================
CREATE TABLE subscriptions (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL UNIQUE REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Stripe
    stripe_customer_id VARCHAR(255) UNIQUE,
    stripe_subscription_id VARCHAR(255) UNIQUE,
    stripe_payment_method_id VARCHAR(255),
    
    -- Plan
    plan VARCHAR(20) NOT NULL CHECK (plan IN ('free', 'pro', 'premium')),
    status VARCHAR(20) NOT NULL 
        CHECK (status IN ('trialing', 'active', 'past_due', 'canceled', 'unpaid', 'incomplete')),
    
    -- Limites
    max_members INTEGER,
    features JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Dates
    current_period_start TIMESTAMP WITH TIME ZONE,
    current_period_end TIMESTAMP WITH TIME ZONE,
    trial_end TIMESTAMP WITH TIME ZONE,
    canceled_at TIMESTAMP WITH TIME ZONE,
    ended_at TIMESTAMP WITH TIME ZONE,
    
    -- Facturation
    amount_cents INTEGER CHECK (amount_cents >= 0),
    currency VARCHAR(3) NOT NULL DEFAULT 'EUR',
    interval VARCHAR(20) CHECK (interval IN ('month', 'year')),
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
CREATE INDEX idx_subscriptions_stripe_customer ON subscriptions(stripe_customer_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
CREATE INDEX idx_subscriptions_trial_end ON subscriptions(trial_end) WHERE trial_end IS NOT NULL;

-- Trigger
CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE subscriptions IS 'Abonnements et facturation Stripe';
COMMENT ON COLUMN subscriptions.features IS 'Fonctionnalités actives selon plan';


-- ============================================
-- TABLE: custom_fields (Champs personnalisés)
-- ============================================
CREATE TABLE custom_fields (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Définition
    field_name VARCHAR(100) NOT NULL,
    field_key VARCHAR(50) NOT NULL CHECK (field_key ~ '^[a-z_]+$'),
    field_type VARCHAR(20) NOT NULL 
        CHECK (field_type IN ('text', 'number', 'date', 'boolean', 'select', 'multi_select')),
    field_options JSONB DEFAULT '{}'::jsonb,
    
    -- Comportement
    is_required BOOLEAN NOT NULL DEFAULT FALSE,
    show_in_stats BOOLEAN NOT NULL DEFAULT FALSE,
    display_order INTEGER NOT NULL DEFAULT 0,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Contrainte unicité
    CONSTRAINT custom_fields_org_key_unique UNIQUE (organization_id, field_key)
);

-- Index
CREATE INDEX idx_custom_fields_organization ON custom_fields(organization_id, display_order) 
    WHERE deleted_at IS NULL;
CREATE INDEX idx_custom_fields_stats ON custom_fields(organization_id) 
    WHERE show_in_stats = TRUE AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE custom_fields ENABLE ROW LEVEL SECURITY;

CREATE POLICY custom_fields_isolation ON custom_fields
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_custom_fields_updated_at
    BEFORE UPDATE ON custom_fields
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE custom_fields IS 'Définition des champs personnalisés par organisation';
COMMENT ON COLUMN custom_fields.field_options IS 'Options JSON: {values: ["Option1", "Option2"]} pour select';


-- ============================================
-- TABLE: audit_logs (Traçabilité)
-- ============================================
CREATE TABLE audit_logs (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Qui
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    user_email VARCHAR(255),
    user_role VARCHAR(20),
    
    -- Quoi
    action VARCHAR(100) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID,
    
    -- Détails
    changes JSONB DEFAULT '{}'::jsonb,
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contexte
    ip_address INET,
    user_agent TEXT,
    
    -- Quand
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index pour requêtes fréquentes
CREATE INDEX idx_audit_logs_organization ON audit_logs(organization_id, created_at DESC);
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_entity ON audit_logs(entity_type, entity_id);
CREATE INDEX idx_audit_logs_created ON audit_logs(created_at DESC);

-- Partitionnement par date (recommandé si gros volume)
-- CREATE TABLE audit_logs_2025_10 PARTITION OF audit_logs
--     FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');

-- Row Level Security
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY audit_logs_isolation ON audit_logs
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Commentaires
COMMENT ON TABLE audit_logs IS 'Logs de toutes les actions utilisateurs (traçabilité complète)';
COMMENT ON COLUMN audit_logs.changes IS 'Changements JSON: {before: {...}, after: {...}}';


-- ============================================
-- VUES MATÉRIALISÉES (Performance)
-- ============================================

-- Vue: Statistiques adhérents pré-calculées
CREATE MATERIALIZED VIEW mv_member_stats AS
SELECT 
    u.id AS user_id,
    u.organization_id,
    u.first_name,
    u.last_name,
    COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled') AS available_courses,
    ROUND(
        (COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE)::numeric / 
        NULLIF(COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled'), 0)) * 100, 
        2
    ) AS attendance_rate,
    MAX(a.actual_attendance_at) AS last_attendance_date,
    CURRENT_DATE - MAX(a.actual_attendance_at)::date AS days_since_last_attendance
FROM users u
LEFT JOIN attendances a ON u.id = a.user_id
LEFT JOIN courses c ON a.course_id = c.id
WHERE u.deleted_at IS NULL 
    AND u.role = 'member'
    AND c.start_datetime >= CURRENT_DATE - INTERVAL '3 months'
GROUP BY u.id, u.organization_id, u.first_name, u.last_name;

-- Index sur vue matérialisée
CREATE UNIQUE INDEX idx_mv_member_stats_user ON mv_member_stats(user_id);
CREATE INDEX idx_mv_member_stats_org ON mv_member_stats(organization_id);
CREATE INDEX idx_mv_member_stats_rate ON mv_member_stats(organization_id, attendance_rate DESC);

-- Commentaire
COMMENT ON MATERIALIZED VIEW mv_member_stats IS 'Stats adhérents pré-calculées (refresh quotidien recommandé)';

-- Fonction de refresh automatique (à scheduler)
CREATE OR REPLACE FUNCTION refresh_member_stats()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_stats;
END;
$$ LANGUAGE plpgsql;


-- ============================================
-- FONCTIONS UTILITAIRES
-- ============================================

-- Fonction: Définir le tenant courant (pour RLS)
CREATE OR REPLACE FUNCTION set_current_tenant(tenant_id UUID)
RETURNS void AS $$
BEGIN
    PERFORM set_config('app.current_tenant', tenant_id::text, false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION set_current_tenant IS 'Définit le tenant courant pour Row Level Security';


-- Fonction: Calculer le taux de présence d'un adhérent
CREATE OR REPLACE FUNCTION calculate_attendance_rate(
    p_user_id UUID,
    p_start_date TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_end_date TIMESTAMP WITH TIME ZONE DEFAULT NULL
)
RETURNS NUMERIC AS $$
DECLARE
    v_attendances INTEGER;
    v_available_courses INTEGER;
BEGIN
    -- Compte les présences effectives
    SELECT COUNT(*) INTO v_attendances
    FROM attendances a
    INNER JOIN courses c ON a.course_id = c.id
    WHERE a.user_id = p_user_id
        AND a.actual_attendance = TRUE
        AND (p_start_date IS NULL OR c.start_datetime >= p_start_date)
        AND (p_end_date IS NULL OR c.start_datetime <= p_end_date);
    
    -- Compte les cours disponibles (non annulés)
    SELECT COUNT(DISTINCT c.id) INTO v_available_courses
    FROM courses c
    WHERE c.organization_id = (SELECT organization_id FROM users WHERE id = p_user_id)
        AND c.status != 'cancelled'
        AND (p_start_date IS NULL OR c.start_datetime >= p_start_date)
        AND (p_end_date IS NULL OR c.start_datetime <= p_end_date);
    
    -- Calcul du taux
    IF v_available_courses = 0 THEN
        RETURN 0;
    END IF;
    
    RETURN ROUND((v_attendances::numeric / v_available_courses) * 100, 2);
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION calculate_attendance_rate IS 'Calcule le taux de présence d''un adhérent sur une période';


-- Fonction: Détecter les adhérents à risque d'abandon
CREATE OR REPLACE FUNCTION detect_at_risk_members(
    p_organization_id UUID,
    p_days_threshold INTEGER DEFAULT 21
)
RETURNS TABLE (
    user_id UUID,
    user_name TEXT,
    days_absent INTEGER,
    previous_rate NUMERIC,
    risk_level TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.id,
        u.first_name || ' ' || u.last_name,
        CURRENT_DATE - MAX(a.actual_attendance_at)::date,
        calculate_attendance_rate(u.id, CURRENT_DATE - INTERVAL '3 months', CURRENT_DATE - INTERVAL '1 month'),
        CASE 
            WHEN CURRENT_DATE - MAX(a.actual_attendance_at)::date >= 30 THEN 'critical'
            WHEN CURRENT_DATE - MAX(a.actual_attendance_at)::date >= p_days_threshold THEN 'warning'
            ELSE 'normal'
        END
    FROM users u
    LEFT JOIN attendances a ON u.id = a.user_id AND a.actual_attendance = TRUE
    WHERE u.organization_id = p_organization_id
        AND u.role = 'member'
        AND u.status = 'active'
        AND u.deleted_at IS NULL
    GROUP BY u.id, u.first_name, u.last_name
    HAVING MAX(a.actual_attendance_at) IS NOT NULL
        AND CURRENT_DATE - MAX(a.actual_attendance_at)::date >= p_days_threshold
    ORDER BY CURRENT_DATE - MAX(a.actual_attendance_at)::date DESC;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION detect_at_risk_members IS 'Détecte les adhérents absents depuis X jours (risque abandon)';


-- ============================================
-- TRIGGERS AVANCÉS
-- ============================================

-- Trigger: Auto-update subscription_status dans organizations
CREATE OR REPLACE FUNCTION sync_subscription_status()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE organizations 
    SET subscription_status = NEW.status
    WHERE id = NEW.organization_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_subscription_to_org
    AFTER INSERT OR UPDATE OF status ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION sync_subscription_status();


-- Trigger: Audit automatique sur modifications importantes
CREATE OR REPLACE FUNCTION log_important_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_logs (
            organization_id,
            user_id,
            action,
            entity_type,
            entity_id,
            changes
        ) VALUES (
            NEW.organization_id,
            current_setting('app.current_user_id', true)::uuid,
            TG_TABLE_NAME || '.updated',
            TG_TABLE_NAME,
            NEW.id,
            jsonb_build_object('before', to_jsonb(OLD), 'after', to_jsonb(NEW))
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_logs (
            organization_id,
            user_id,
            action,
            entity_type,
            entity_id,
            changes
        ) VALUES (
            OLD.organization_id,
            current_setting('app.current_user_id', true)::uuid,
            TG_TABLE_NAME || '.deleted',
            TG_TABLE_NAME,
            OLD.id,
            jsonb_build_object('before', to_jsonb(OLD))
        );
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Appliquer l'audit sur les tables critiques
CREATE TRIGGER audit_courses_changes
    AFTER UPDATE OR DELETE ON courses
    FOR EACH ROW
    EXECUTE FUNCTION log_important_changes();

CREATE TRIGGER audit_attendances_changes
    AFTER UPDATE OR DELETE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION log_important_changes();


-- ============================================
-- CONTRAINTES D'INTÉGRITÉ AVANCÉES
-- ============================================

-- Vérifier que le coach appartient à l'organisation
ALTER TABLE courses ADD CONSTRAINT check_coach_organization
    CHECK (
        coach_id IS NULL OR 
        EXISTS (
            SELECT 1 FROM users 
            WHERE id = coach_id 
            AND organization_id = courses.organization_id
            AND role IN ('coach', 'admin')
        )
    );

-- Vérifier cohérence des dates de récurrence
ALTER TABLE courses ADD CONSTRAINT check_recurrence_dates
    CHECK (
        NOT is_recurring OR 
        (recurrence_rule IS NOT NULL)
    );


-- ============================================
-- GRANTS ET SÉCURITÉ
-- ============================================

-- Rôle application (utilisé par le backend)
CREATE ROLE app_user WITH LOGIN PASSWORD 'change_me_in_production';

-- Permissions strictes
GRANT CONNECT ON DATABASE postgres TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO app_user;

-- Lecture seule pour les rapports
CREATE ROLE app_readonly WITH LOGIN PASSWORD 'change_me_readonly';
GRANT CONNECT ON DATABASE postgres TO app_readonly;
GRANT USAGE ON SCHEMA public TO app_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_readonly;


-- ============================================
-- DONNÉES DE TEST (Optionnel)
-- ============================================

-- Insertion organisation de test
INSERT INTO organizations (id, name, slug, email, subscription_plan, subscription_status)
VALUES (
    'a0000000-0000-0000-0000-000000000001',
    'Krav Maga Lyon Centre',
    'krav-maga-lyon-centre',
    'contact@kravlyon.fr',
    'pro',
    'active'
);

-- Insertion utilisateurs de test
INSERT INTO users (organization_id, email, password_hash, first_name, last_name, role)
VALUES 
    ('a0000000-0000-0000-0000-000000000001', 'admin@kravlyon.fr', '$2b$12$dummy_hash', 'Sophie', 'Bernard', 'admin'),
    ('a0000000-0000-0000-0000-000000000001', 'marc@kravlyon.fr', '$2b$12$dummy_hash', 'Marc', 'Petit', 'coach'),
    ('a0000000-0000-0000-0000-000000000001', 'lisa@email.com', '$2b$12$dummy_hash', 'Lisa', 'Martin', 'member');


-- ============================================
-- MAINTENANCE ET MONITORING
-- ============================================

-- ============================================
-- MAINTENANCE ET MONITORING
-- ============================================

-- Vue pour monitoring des performances
CREATE VIEW v_table_sizes AS
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) AS indexes_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

COMMENT ON VIEW v_table_sizes IS 'Taille des tables et indexes pour monitoring';


-- Vue pour monitoring des index inutilisés
CREATE VIEW v_unused_indexes AS
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
    AND indexrelname NOT LIKE 'pg_toast%'
    AND schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;

COMMENT ON VIEW v_unused_indexes IS 'Index jamais utilisés (candidats pour suppression)';


-- Vue pour monitoring des connexions actives
CREATE VIEW v_active_connections AS
SELECT 
    datname,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change,
    wait_event_type,
    wait_event,
    LEFT(query, 100) AS query_preview
FROM pg_stat_activity
WHERE datname = current_database()
    AND pid != pg_backend_pid()
ORDER BY query_start;

COMMENT ON VIEW v_active_connections IS 'Connexions actives à la base de données';


-- Vue pour statistiques par organisation
CREATE VIEW v_organization_stats AS
SELECT 
    o.id,
    o.name,
    o.subscription_plan,
    COUNT(DISTINCT u.id) FILTER (WHERE u.role = 'member' AND u.deleted_at IS NULL) AS total_members,
    COUNT(DISTINCT u.id) FILTER (WHERE u.role = 'coach' AND u.deleted_at IS NULL) AS total_coaches,
    COUNT(DISTINCT c.id) FILTER (WHERE c.deleted_at IS NULL) AS total_courses,
    COUNT(DISTINCT a.id) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    ROUND(
        AVG(
            (SELECT calculate_attendance_rate(u2.id, CURRENT_DATE - INTERVAL '30 days', CURRENT_DATE)
             FROM users u2 
             WHERE u2.organization_id = o.id AND u2.role = 'member' AND u2.deleted_at IS NULL)
        ), 2
    ) AS avg_attendance_rate_30d
FROM organizations o
LEFT JOIN users u ON o.id = u.organization_id
LEFT JOIN courses c ON o.id = c.organization_id
LEFT JOIN attendances a ON o.id = a.organization_id
WHERE o.deleted_at IS NULL
GROUP BY o.id, o.name, o.subscription_plan;

COMMENT ON VIEW v_organization_stats IS 'Statistiques agrégées par organisation';


-- ============================================
-- PROCÉDURES DE MAINTENANCE
-- ============================================

-- Procédure: Nettoyage des données obsolètes
CREATE OR REPLACE PROCEDURE cleanup_old_data(
    p_audit_logs_retention_days INTEGER DEFAULT 365,
    p_deleted_records_retention_days INTEGER DEFAULT 90
)
LANGUAGE plpgsql
AS $
BEGIN
    -- Supprimer les vieux logs d'audit
    DELETE FROM audit_logs 
    WHERE created_at < CURRENT_DATE - (p_audit_logs_retention_days || ' days')::INTERVAL;
    
    RAISE NOTICE 'Audit logs nettoyés: % lignes supprimées', 
        (SELECT count(*) FROM audit_logs WHERE created_at < CURRENT_DATE - (p_audit_logs_retention_days || ' days')::INTERVAL);
    
    -- Supprimer définitivement les enregistrements soft-deleted anciens
    DELETE FROM users 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    DELETE FROM courses 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    DELETE FROM organizations 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    RAISE NOTICE 'Nettoyage terminé';
END;
$;

COMMENT ON PROCEDURE cleanup_old_data IS 'Nettoyage automatique des données obsolètes (à scheduler)';


-- Procédure: Vacuum et analyse automatiques
CREATE OR REPLACE PROCEDURE maintenance_vacuum_analyze()
LANGUAGE plpgsql
AS $
BEGIN
    VACUUM ANALYZE organizations;
    VACUUM ANALYZE users;
    VACUUM ANALYZE courses;
    VACUUM ANALYZE attendances;
    VACUUM ANALYZE subscriptions;
    VACUUM ANALYZE custom_fields;
    VACUUM ANALYZE audit_logs;
    
    RAISE NOTICE 'Vacuum et analyse terminés';
END;
$;

COMMENT ON PROCEDURE maintenance_vacuum_analyze IS 'Vacuum et analyse des tables principales (à scheduler quotidiennement)';


-- Procédure: Refresh des vues matérialisées
CREATE OR REPLACE PROCEDURE refresh_all_materialized_views()
LANGUAGE plpgsql
AS $
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_stats;
    RAISE NOTICE 'Vues matérialisées rafraîchies';
END;
$;

COMMENT ON PROCEDURE refresh_all_materialized_views IS 'Rafraîchissement de toutes les vues matérialisées (à scheduler quotidiennement)';


-- ============================================
-- BACKUP ET RESTORE
-- ============================================

-- Fonction: Export des données d'une organisation (RGPD)
CREATE OR REPLACE FUNCTION export_organization_data(p_organization_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $
DECLARE
    v_data JSONB;
BEGIN
    SELECT jsonb_build_object(
        'organization', (SELECT row_to_json(o.*) FROM organizations o WHERE id = p_organization_id),
        'users', (SELECT jsonb_agg(row_to_json(u.*)) FROM users u WHERE organization_id = p_organization_id AND deleted_at IS NULL),
        'courses', (SELECT jsonb_agg(row_to_json(c.*)) FROM courses c WHERE organization_id = p_organization_id AND deleted_at IS NULL),
        'attendances', (SELECT jsonb_agg(row_to_json(a.*)) FROM attendances a WHERE organization_id = p_organization_id),
        'custom_fields', (SELECT jsonb_agg(row_to_json(cf.*)) FROM custom_fields cf WHERE organization_id = p_organization_id AND deleted_at IS NULL)
    ) INTO v_data;
    
    RETURN v_data;
END;
$;

COMMENT ON FUNCTION export_organization_data IS 'Export complet des données d''une organisation (conformité RGPD)';


-- Fonction: Anonymisation d'un utilisateur (RGPD - droit à l'oubli)
CREATE OR REPLACE FUNCTION anonymize_user(p_user_id UUID)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $
BEGIN
    UPDATE users
    SET 
        email = 'deleted_' || id || '@anonymized.local',
        first_name = 'Utilisateur',
        last_name = '[Supprimé]',
        phone = NULL,
        date_of_birth = NULL,
        metadata = '{}'::jsonb,
        password_hash = 'ANONYMIZED',
        deleted_at = CURRENT_TIMESTAMP
    WHERE id = p_user_id;
    
    -- Log de l'action
    INSERT INTO audit_logs (
        organization_id,
        user_id,
        action,
        entity_type,
        entity_id,
        metadata
    ) VALUES (
        (SELECT organization_id FROM users WHERE id = p_user_id),
        p_user_id,
        'user.anonymized',
        'users',
        p_user_id,
        jsonb_build_object('anonymized_at', CURRENT_TIMESTAMP, 'reason', 'RGPD_right_to_be_forgotten')
    );
    
    RAISE NOTICE 'Utilisateur % anonymisé', p_user_id;
END;
$;

COMMENT ON FUNCTION anonymize_user IS 'Anonymisation d''un utilisateur (RGPD - droit à l''oubli)';


-- ============================================
-- INDEXES PARTIELS AVANCÉS (Optimisation)
-- ============================================

-- Index pour les cours à venir uniquement (requête très fréquente)
CREATE INDEX idx_courses_upcoming_detailed ON courses(organization_id, start_datetime, status)
    WHERE start_datetime > CURRENT_TIMESTAMP 
        AND status = 'scheduled' 
        AND deleted_at IS NULL;

-- Index pour les adhérents actifs récents
CREATE INDEX idx_users_active_recent ON users(organization_id, last_login_at DESC)
    WHERE status = 'active' 
        AND deleted_at IS NULL
        AND last_login_at > CURRENT_TIMESTAMP - INTERVAL '30 days';

-- Index pour présences du mois en cours (statistiques temps réel)
CREATE INDEX idx_attendances_current_month ON attendances(organization_id, user_id, actual_attendance)
    WHERE actual_attendance_at >= date_trunc('month', CURRENT_DATE)
        AND actual_attendance IS NOT NULL;


-- ============================================
-- POLICIES RLS AVANCÉES (Sécurité fine)
-- ============================================

-- Policy: Les coachs ne voient que leurs cours
CREATE POLICY coaches_own_courses ON courses
    FOR SELECT
    USING (
        organization_id = current_setting('app.current_tenant', true)::uuid
        AND (
            coach_id = current_setting('app.current_user_id', true)::uuid
            OR EXISTS (
                SELECT 1 FROM users 
                WHERE id = current_setting('app.current_user_id', true)::uuid 
                AND role IN ('admin')
            )
        )
    );

-- Policy: Les adhérents ne voient que leurs propres présences détaillées
CREATE POLICY members_own_attendances ON attendances
    FOR SELECT
    USING (
        organization_id = current_setting('app.current_tenant', true)::uuid
        AND (
            user_id = current_setting('app.current_user_id', true)::uuid
            OR EXISTS (
                SELECT 1 FROM users 
                WHERE id = current_setting('app.current_user_id', true)::uuid 
                AND role IN ('admin', 'coach')
            )
        )
    );


-- ============================================
-- CONTRAINTES DE VALIDATION MÉTIER
-- ============================================

-- Vérifier qu'un cours ne dépasse pas 24h
ALTER TABLE courses ADD CONSTRAINT check_course_max_duration
    CHECK (end_datetime - start_datetime <= INTERVAL '24 hours');

-- Vérifier qu'on ne peut pas marquer présent à un cours dans le futur
CREATE OR REPLACE FUNCTION check_attendance_not_future()
RETURNS TRIGGER AS $
BEGIN
    IF NEW.actual_attendance IS NOT NULL AND NEW.actual_attendance_at IS NOT NULL THEN
        IF NEW.actual_attendance_at > (SELECT end_datetime FROM courses WHERE id = NEW.course_id) + INTERVAL '2 hours' THEN
            RAISE EXCEPTION 'Impossible de marquer une présence plus de 2h après la fin du cours';
        END IF;
    END IF;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER validate_attendance_timing
    BEFORE INSERT OR UPDATE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION check_attendance_not_future();


-- ============================================
-- FONCTIONS D'AGRÉGATION PERSONNALISÉES
-- ============================================

-- Fonction: Statistiques complètes d'un adhérent
CREATE OR REPLACE FUNCTION get_member_complete_stats(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $
DECLARE
    v_stats JSONB;
BEGIN
    SELECT jsonb_build_object(
        'user_id', p_user_id,
        'total_courses_available', (
            SELECT COUNT(*) 
            FROM courses c
            WHERE c.organization_id = (SELECT organization_id FROM users WHERE id = p_user_id)
                AND c.status != 'cancelled'
                AND c.start_datetime >= (SELECT join_date FROM users WHERE id = p_user_id)
                AND c.deleted_at IS NULL
        ),
        'total_attendances', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'attendance_rate', calculate_attendance_rate(p_user_id),
        'attendance_rate_30d', calculate_attendance_rate(p_user_id, CURRENT_DATE - INTERVAL '30 days', CURRENT_DATE),
        'attendance_rate_90d', calculate_attendance_rate(p_user_id, CURRENT_DATE - INTERVAL '90 days', CURRENT_DATE),
        'last_attendance', (
            SELECT MAX(actual_attendance_at) 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'days_since_last_attendance', (
            SELECT CURRENT_DATE - MAX(actual_attendance_at)::date 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'current_streak', (
            -- Série de présences consécutives (simplifié)
            SELECT COUNT(*)
            FROM attendances a
            INNER JOIN courses c ON a.course_id = c.id
            WHERE a.user_id = p_user_id 
                AND a.actual_attendance = TRUE
                AND c.start_datetime >= CURRENT_DATE - INTERVAL '30 days'
        ),
        'total_intentions', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE user_id = p_user_id AND intention = 'will_attend'
        ),
        'intention_reliability', (
            -- Fiabilité des inscriptions
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE intention = 'will_attend' AND actual_attendance = TRUE)::numeric /
                NULLIF(COUNT(*) FILTER (WHERE intention = 'will_attend'), 0)) * 100, 2
            )
            FROM attendances
            WHERE user_id = p_user_id
        )
    ) INTO v_stats;
    
    RETURN v_stats;
END;
$;

COMMENT ON FUNCTION get_member_complete_stats IS 'Statistiques complètes d''un adhérent (toutes périodes)';


-- Fonction: Statistiques d'un cours
CREATE OR REPLACE FUNCTION get_course_stats(p_course_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $
DECLARE
    v_stats JSONB;
BEGIN
    SELECT jsonb_build_object(
        'course_id', p_course_id,
        'total_enrolled', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE course_id = p_course_id AND intention = 'will_attend'
        ),
        'total_attended', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE course_id = p_course_id AND actual_attendance = TRUE
        ),
        'occupancy_rate', (
            SELECT CASE 
                WHEN c.max_capacity IS NOT NULL THEN
                    ROUND((COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE)::numeric / c.max_capacity) * 100, 2)
                ELSE NULL
            END
            FROM courses c
            LEFT JOIN attendances a ON c.id = a.course_id
            WHERE c.id = p_course_id
            GROUP BY c.max_capacity
        ),
        'no_show_rate', (
            -- Taux de non-présentation (inscrits mais absents)
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE intention = 'will_attend' AND actual_attendance = FALSE)::numeric /
                NULLIF(COUNT(*) FILTER (WHERE intention = 'will_attend'), 0)) * 100, 2
            )
            FROM attendances
            WHERE course_id = p_course_id
        ),
        'walk_ins', (
            -- Présents non-inscrits
            SELECT COUNT(*)
            FROM attendances
            WHERE course_id = p_course_id 
                AND intention IS NULL 
                AND actual_attendance = TRUE
        )
    ) INTO v_stats;
    
    RETURN v_stats;
END;
$;

COMMENT ON FUNCTION get_course_stats IS 'Statistiques détaillées d''un cours';


-- ============================================
-- SCHEDULING (À configurer via pg_cron ou cron externe)
-- ============================================

-- Extension pg_cron (optionnelle, nécessite installation)
-- CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Exemples de tâches planifiées (à décommenter si pg_cron installé)
/*
-- Refresh des stats quotidien à 2h du matin
SELECT cron.schedule('refresh-stats', '0 2 * * *', $
    CALL refresh_all_materialized_views();
$);

-- Nettoyage hebdomadaire le dimanche à 3h
SELECT cron.schedule('cleanup-old-data', '0 3 * * 0', $
    CALL cleanup_old_data(365, 90);
$);

-- Vacuum quotidien à 4h
SELECT cron.schedule('daily-vacuum', '0 4 * * *', $
    CALL maintenance_vacuum_analyze();
$);
*/


-- ============================================
-- DOCUMENTATION FINALE
-- ============================================

COMMENT ON DATABASE postgres IS 'KravStats - Application de gestion de présences sportives multi-tenant';

-- Documentation des conventions
/*
CONVENTIONS DE NOMMAGE:
- Tables: pluriel, snake_case (ex: users, courses, attendances)
- Colonnes: snake_case (ex: first_name, created_at)
- Index: idx_tablename_columns (ex: idx_users_email_org)
- Contraintes: check_tablename_description (ex: check_course_max_duration)
- Fonctions: verbe_nom (ex: calculate_attendance_rate)
- Vues matérialisées: mv_description (ex: mv_member_stats)
- Triggers: nom_action (ex: update_users_updated_at)

TYPES DE DONNÉES:
- ID: UUID (sécurité, distribution)
- Dates: TIMESTAMP WITH TIME ZONE (internationalisation)
- Textes courts: VARCHAR avec limite
- Textes longs: TEXT
- Booléens: BOOLEAN (jamais NULL si logique binaire)
- Montants: INTEGER en centimes (éviter DECIMAL pour les montants)
- Données flexibles: JSONB (indexable avec GIN)

SÉCURITÉ:
- Row Level Security (RLS) activé sur toutes les tables multi-tenant
- Soft delete (deleted_at) pour traçabilité
- Audit logs pour actions critiques
- Contraintes CHECK pour validation côté DB
- SECURITY DEFINER pour fonctions sensibles

PERFORMANCE:
- Index partiels (WHERE) pour requêtes fréquentes
- Index composites pour requêtes complexes
- Vues matérialisées pour agrégations coûteuses
- Index GIN pour JSONB
- Contraintes de clés étrangères avec ON DELETE CASCADE/SET NULL

MAINTENANCE:
- Vacuum automatique (configurer autovacuum)
- Refresh vues matérialisées quotidien
- Nettoyage logs > 1 an
- Monitoring taille tables/index
- Backup quotidien (pg_dump ou solution cloud)

SCALABILITÉ:
- Partitionnement par date pour audit_logs si > 10M lignes
- Connection pooling (PgBouncer) recommandé
- Read replicas pour reporting (PostgreSQL streaming replication)
- Sharding par organization_id si > 1000 tenants
*/


-- ============================================
-- FIN DU SCHÉMA
-- ============================================

-- Afficher un résumé
DO $
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Schéma de base de données créé avec succès';
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Tables créées: %', (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_type = 'BASE TABLE');
    RAISE NOTICE 'Index créés: %', (SELECT COUNT(*) FROM pg_indexes WHERE schemaname = 'public');
    RAISE NOTICE 'Fonctions créées: %', (SELECT COUNT(*) FROM pg_proc WHERE pronamespace = 'public'::regnamespace);
    RAISE NOTICE 'Triggers créés: %', (SELECT COUNT(*) FROM pg_trigger WHERE tgrelid IN (SELECT oid FROM pg_class WHERE relnamespace = 'public'::regnamespace));
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Prochaines étapes:';
    RAISE NOTICE '1. Configurer les variables d''environnement';
    RAISE NOTICE '2. Créer les rôles app_user et app_readonly';
    RAISE NOTICE '3. Configurer pg_cron ou cron système pour maintenance';
    RAISE NOTICE '4. Configurer les backups automatiques';
    RAISE NOTICE '5. Tester les fonctions avec données de test';
    RAISE NOTICE '========================================';
END $;),
    password_hash VARCHAR(255) NOT NULL,
    
    -- Identité
    first_name VARCHAR(100) NOT NULL CHECK (char_length(first_name) >= 1),
    last_name VARCHAR(100) NOT NULL CHECK (char_length(last_name) >= 1),
    phone VARCHAR(20),
    date_of_birth DATE CHECK (date_of_birth < CURRENT_DATE),
    
    -- Rôle et statut
    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'coach', 'member')),
    status VARCHAR(20) NOT NULL DEFAULT 'active' 
        CHECK (status IN ('active', 'inactive', 'suspended')),
    
    -- Dates importantes
    join_date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Métadonnées flexibles (ceintures, certificat médical, etc.)
    metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Sécurité
    email_verified BOOLEAN NOT NULL DEFAULT FALSE,
    last_login_at TIMESTAMP WITH TIME ZONE,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Constraints
    CONSTRAINT users_email_org_unique UNIQUE (email, organization_id)
);

-- Index optimisés
CREATE UNIQUE INDEX idx_users_email_org ON users(email, organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_organization_id ON users(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_role ON users(organization_id, role) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_status ON users(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_password_reset ON users(password_reset_token) WHERE password_reset_token IS NOT NULL;
CREATE INDEX idx_users_metadata_gin ON users USING gin(metadata jsonb_path_ops);

-- Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY users_isolation ON users
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE users IS 'Tous les utilisateurs (admins, coachs, adhérents)';
COMMENT ON COLUMN users.metadata IS 'Données flexibles: belt_level, medical_cert, preferences, etc.';
COMMENT ON COLUMN users.password_hash IS 'Hash bcrypt du mot de passe (coût 12)';


-- ============================================
-- TABLE: courses (Cours ponctuels et récurrents)
-- ============================================
CREATE TABLE courses (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Informations de base
    title VARCHAR(255) NOT NULL CHECK (char_length(title) >= 2),
    description TEXT,
    course_type VARCHAR(50),
    
    -- Horaires
    start_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    end_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    CHECK (end_datetime > start_datetime),
    
    -- Colonnes dérivées pour analytics (dénormalisation intentionnelle)
    start_date DATE GENERATED ALWAYS AS (start_datetime::date) STORED,
    start_time TIME GENERATED ALWAYS AS (start_datetime::time) STORED,
    day_of_week INTEGER GENERATED ALWAYS AS (EXTRACT(ISODOW FROM start_datetime)) STORED,
    week_of_year INTEGER GENERATED ALWAYS AS (EXTRACT(WEEK FROM start_datetime)) STORED,
    month INTEGER GENERATED ALWAYS AS (EXTRACT(MONTH FROM start_datetime)) STORED,
    year INTEGER GENERATED ALWAYS AS (EXTRACT(YEAR FROM start_datetime)) STORED,
    quarter INTEGER GENERATED ALWAYS AS (EXTRACT(QUARTER FROM start_datetime)) STORED,
    duration_minutes INTEGER GENERATED ALWAYS AS (EXTRACT(EPOCH FROM (end_datetime - start_datetime))/60) STORED,
    
    -- Lieu
    location VARCHAR(255),
    
    -- Coach
    coach_id UUID REFERENCES users(id) ON DELETE SET NULL,
    
    -- Capacité
    max_capacity INTEGER CHECK (max_capacity > 0 OR max_capacity IS NULL),
    
    -- Récurrence
    is_recurring BOOLEAN NOT NULL DEFAULT FALSE,
    recurrence_rule JSONB CHECK (
        recurrence_rule IS NULL OR 
        (recurrence_rule ? 'frequency' AND recurrence_rule ? 'day_of_week')
    ),
    parent_recurrence_id UUID REFERENCES courses(id) ON DELETE SET NULL,
    
    -- Statut
    status VARCHAR(20) NOT NULL DEFAULT 'scheduled'
        CHECK (status IN ('scheduled', 'ongoing', 'completed', 'cancelled')),
    cancellation_reason TEXT,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index haute performance POUR ANALYTICS
CREATE INDEX idx_courses_organization_id ON courses(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_start_datetime ON courses(organization_id, start_datetime DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_coach_id ON courses(coach_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_status ON courses(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_parent_recurrence ON courses(parent_recurrence_id) WHERE parent_recurrence_id IS NOT NULL;
CREATE INDEX idx_courses_date_range ON courses(organization_id, start_datetime, end_datetime) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_recurrence_gin ON courses USING gin(recurrence_rule jsonb_path_ops) WHERE recurrence_rule IS NOT NULL;

-- INDEX SPÉCIAUX POUR ANALYTICS (colonnes générées)
CREATE INDEX idx_courses_analytics_date ON courses(organization_id, start_date, status) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_analytics_dow ON courses(organization_id, day_of_week, status) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_analytics_month ON courses(organization_id, year, month, status) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_analytics_quarter ON courses(organization_id, year, quarter, status) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_analytics_week ON courses(organization_id, year, week_of_year, status) WHERE deleted_at IS NULL;

-- Index pour recherches temporelles optimisées
CREATE INDEX idx_courses_upcoming ON courses(organization_id, start_datetime) 
    WHERE status = 'scheduled' AND deleted_at IS NULL;
CREATE INDEX idx_courses_past ON courses(organization_id, start_datetime DESC) 
    WHERE status = 'completed' AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE courses ENABLE ROW LEVEL SECURITY;

CREATE POLICY courses_isolation ON courses
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_courses_updated_at
    BEFORE UPDATE ON courses
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE courses IS 'Cours (ponctuels et récurrents) - OPTIMISÉ ANALYTICS avec colonnes générées';
COMMENT ON COLUMN courses.start_date IS 'Date extraite (GENERATED) pour regroupements analytics';
COMMENT ON COLUMN courses.day_of_week IS 'Jour semaine (1=Lundi, 7=Dimanche) pour analyses tendances';
COMMENT ON COLUMN courses.duration_minutes IS 'Durée en minutes (GENERATED) pour analyses durées moyennes';


-- ============================================
-- TABLE: attendances (Présences et intentions)
-- TABLE FACT CENTRALE POUR ANALYTICS
-- ============================================
CREATE TABLE attendances (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    course_id UUID NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Intention (avant le cours)
    intention VARCHAR(20) CHECK (intention IN ('will_attend', 'will_not_attend') OR intention IS NULL),
    intention_at TIMESTAMP WITH TIME ZONE,
    
    -- Présence effective (pendant/après le cours)
    actual_attendance BOOLEAN,
    actual_attendance_at TIMESTAMP WITH TIME ZONE,
    
    -- Colonnes dérivées POUR ANALYTICS (dénormalisation)
    attendance_date DATE GENERATED ALWAYS AS (actual_attendance_at::date) STORED,
    attendance_day_of_week INTEGER GENERATED ALWAYS AS (EXTRACT(ISODOW FROM actual_attendance_at)) STORED,
    attendance_week INTEGER GENERATED ALWAYS AS (EXTRACT(WEEK FROM actual_attendance_at)) STORED,
    attendance_month INTEGER GENERATED ALWAYS AS (EXTRACT(MONTH FROM actual_attendance_at)) STORED,
    attendance_year INTEGER GENERATED ALWAYS AS (EXTRACT(YEAR FROM actual_attendance_at)) STORED,
    
    -- Traçabilité
    marked_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    marked_by_role VARCHAR(20) CHECK (marked_by_role IN ('admin', 'coach', 'member') OR marked_by_role IS NULL),
    is_locked BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Métriques dérivées (pour éviter recalculs)
    is_no_show BOOLEAN GENERATED ALWAYS AS (
        intention = 'will_attend' AND actual_attendance = FALSE
    ) STORED,
    is_walk_in BOOLEAN GENERATED ALWAYS AS (
        intention IS NULL AND actual_attendance = TRUE
    ) STORED,
    is_reliable BOOLEAN GENERATED ALWAYS AS (
        intention = 'will_attend' AND actual_attendance = TRUE
    ) STORED,
    
    -- Notes
    notes TEXT,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contrainte unicité
    CONSTRAINT attendances_course_user_unique UNIQUE (course_id, user_id)
);

-- Index critiques pour performance
CREATE UNIQUE INDEX idx_attendances_course_user ON attendances(course_id, user_id);
CREATE INDEX idx_attendances_organization_id ON attendances(organization_id);
CREATE INDEX idx_attendances_user_id ON attendances(user_id);
CREATE INDEX idx_attendances_course_id ON attendances(course_id);

-- Index pour statistiques optimisées
CREATE INDEX idx_attendances_actual ON attendances(organization_id, user_id, actual_attendance) 
    WHERE actual_attendance IS NOT NULL;
CREATE INDEX idx_attendances_intention ON attendances(organization_id, course_id, intention) 
    WHERE intention IS NOT NULL;
CREATE INDEX idx_attendances_user_actual_date ON attendances(user_id, actual_attendance_at) 
    WHERE actual_attendance = TRUE;

-- INDEX ANALYTICS AVANCÉS (colonnes générées)
CREATE INDEX idx_attendances_analytics_date ON attendances(organization_id, attendance_date, actual_attendance) 
    WHERE actual_attendance IS NOT NULL;
CREATE INDEX idx_attendances_analytics_dow ON attendances(organization_id, attendance_day_of_week, actual_attendance) 
    WHERE actual_attendance IS NOT NULL;
CREATE INDEX idx_attendances_analytics_month ON attendances(organization_id, attendance_year, attendance_month, actual_attendance) 
    WHERE actual_attendance IS NOT NULL;
CREATE INDEX idx_attendances_analytics_week ON attendances(organization_id, attendance_year, attendance_week) 
    WHERE actual_attendance IS NOT NULL;

-- Index pour métriques dérivées (no-show, walk-in, reliable)
CREATE INDEX idx_attendances_no_show ON attendances(organization_id, is_no_show) WHERE is_no_show = TRUE;
CREATE INDEX idx_attendances_walk_in ON attendances(organization_id, is_walk_in) WHERE is_walk_in = TRUE;
CREATE INDEX idx_attendances_reliable ON attendances(organization_id, is_reliable) WHERE is_reliable = TRUE;

-- Index composite pour requêtes fréquentes
CREATE INDEX idx_attendances_stats ON attendances(organization_id, user_id, actual_attendance, actual_attendance_at)
    WHERE actual_attendance IS NOT NULL;

-- Row Level Security
ALTER TABLE attendances ENABLE ROW LEVEL SECURITY;

CREATE POLICY attendances_isolation ON attendances
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_attendances_updated_at
    BEFORE UPDATE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE attendances IS 'TABLE FACT CENTRALE - Intentions et présences avec colonnes analytics';
COMMENT ON COLUMN attendances.is_no_show IS 'COMPUTED: Inscrit mais absent (mauvais signal)';
COMMENT ON COLUMN attendances.is_walk_in IS 'COMPUTED: Présent sans inscription (spontané)';
COMMENT ON COLUMN attendances.is_reliable IS 'COMPUTED: Inscrit et présent (fiable)';


-- ============================================
-- TABLE: subscriptions (Abonnements Stripe)
-- ============================================
CREATE TABLE subscriptions (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL UNIQUE REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Stripe
    stripe_customer_id VARCHAR(255) UNIQUE,
    stripe_subscription_id VARCHAR(255) UNIQUE,
    stripe_payment_method_id VARCHAR(255),
    
    -- Plan
    plan VARCHAR(20) NOT NULL CHECK (plan IN ('free', 'pro', 'premium')),
    status VARCHAR(20) NOT NULL 
        CHECK (status IN ('trialing', 'active', 'past_due', 'canceled', 'unpaid', 'incomplete')),
    
    -- Limites
    max_members INTEGER,
    features JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Dates
    current_period_start TIMESTAMP WITH TIME ZONE,
    current_period_end TIMESTAMP WITH TIME ZONE,
    trial_end TIMESTAMP WITH TIME ZONE,
    canceled_at TIMESTAMP WITH TIME ZONE,
    ended_at TIMESTAMP WITH TIME ZONE,
    
    -- Facturation
    amount_cents INTEGER CHECK (amount_cents >= 0),
    currency VARCHAR(3) NOT NULL DEFAULT 'EUR',
    interval VARCHAR(20) CHECK (interval IN ('month', 'year')),
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
CREATE INDEX idx_subscriptions_stripe_customer ON subscriptions(stripe_customer_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
CREATE INDEX idx_subscriptions_trial_end ON subscriptions(trial_end) WHERE trial_end IS NOT NULL;

-- Trigger
CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE subscriptions IS 'Abonnements et facturation Stripe';
COMMENT ON COLUMN subscriptions.features IS 'Fonctionnalités actives selon plan';


-- ============================================
-- TABLE: custom_fields (Champs personnalisés)
-- ============================================
CREATE TABLE custom_fields (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Définition
    field_name VARCHAR(100) NOT NULL,
    field_key VARCHAR(50) NOT NULL CHECK (field_key ~ '^[a-z_]+-- ============================================
-- SCHÉMA DE BASE DE DONNÉES - KRAVSTATS
-- PostgreSQL 15+
-- Multi-tenant avec Row Level Security
-- ============================================

-- Extensions nécessaires
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ============================================
-- TABLE: organizations (Clubs/Tenants)
-- ============================================
CREATE TABLE organizations (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    
    -- Identité
    name VARCHAR(255) NOT NULL CHECK (char_length(name) >= 2),
    slug VARCHAR(100) UNIQUE NOT NULL CHECK (slug ~ '^[a-z0-9-]+$'),
    
    -- Contact
    email VARCHAR(255) CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}$'),
    phone VARCHAR(20),
    address TEXT,
    
    -- Branding
    logo_url VARCHAR(500),
    
    -- Configuration (JSONB pour flexibilité)
    settings JSONB NOT NULL DEFAULT '{
        "lock_attendance_by_coach": true,
        "default_capacity": 15,
        "season_start_month": 9,
        "timezone": "Europe/Paris"
    }'::jsonb,
    
    -- Abonnement
    subscription_status VARCHAR(20) NOT NULL DEFAULT 'trial' 
        CHECK (subscription_status IN ('trial', 'active', 'past_due', 'canceled', 'suspended')),
    subscription_plan VARCHAR(20) DEFAULT 'free'
        CHECK (subscription_plan IN ('free', 'pro', 'premium')),
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index
CREATE INDEX idx_organizations_slug ON organizations(slug) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_subscription_status ON organizations(subscription_status) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_trial_ends ON organizations(trial_ends_at) WHERE trial_ends_at IS NOT NULL;

-- Trigger pour updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_organizations_updated_at
    BEFORE UPDATE ON organizations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE organizations IS 'Clubs/Associations (tenants multi-tenant)';
COMMENT ON COLUMN organizations.settings IS 'Configuration JSON: lock_attendance_by_coach, default_capacity, etc.';


-- ============================================
-- TABLE: users (Tous les utilisateurs)
-- ============================================
CREATE TABLE users (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Authentification
    email VARCHAR(255) NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}$'),
    password_hash VARCHAR(255) NOT NULL,
    
    -- Identité
    first_name VARCHAR(100) NOT NULL CHECK (char_length(first_name) >= 1),
    last_name VARCHAR(100) NOT NULL CHECK (char_length(last_name) >= 1),
    phone VARCHAR(20),
    date_of_birth DATE CHECK (date_of_birth < CURRENT_DATE),
    
    -- Rôle et statut
    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'coach', 'member')),
    status VARCHAR(20) NOT NULL DEFAULT 'active' 
        CHECK (status IN ('active', 'inactive', 'suspended')),
    
    -- Dates importantes
    join_date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Métadonnées flexibles (ceintures, certificat médical, etc.)
    metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Sécurité
    email_verified BOOLEAN NOT NULL DEFAULT FALSE,
    last_login_at TIMESTAMP WITH TIME ZONE,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Constraints
    CONSTRAINT users_email_org_unique UNIQUE (email, organization_id)
);

-- Index optimisés
CREATE UNIQUE INDEX idx_users_email_org ON users(email, organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_organization_id ON users(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_role ON users(organization_id, role) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_status ON users(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_password_reset ON users(password_reset_token) WHERE password_reset_token IS NOT NULL;
CREATE INDEX idx_users_metadata_gin ON users USING gin(metadata jsonb_path_ops);

-- Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY users_isolation ON users
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE users IS 'Tous les utilisateurs (admins, coachs, adhérents)';
COMMENT ON COLUMN users.metadata IS 'Données flexibles: belt_level, medical_cert, preferences, etc.';
COMMENT ON COLUMN users.password_hash IS 'Hash bcrypt du mot de passe (coût 12)';


-- ============================================
-- TABLE: courses (Cours ponctuels et récurrents)
-- ============================================
CREATE TABLE courses (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Informations de base
    title VARCHAR(255) NOT NULL CHECK (char_length(title) >= 2),
    description TEXT,
    course_type VARCHAR(50),
    
    -- Horaires
    start_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    end_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    CHECK (end_datetime > start_datetime),
    
    -- Lieu
    location VARCHAR(255),
    
    -- Coach
    coach_id UUID REFERENCES users(id) ON DELETE SET NULL,
    
    -- Capacité
    max_capacity INTEGER CHECK (max_capacity > 0 OR max_capacity IS NULL),
    
    -- Récurrence
    is_recurring BOOLEAN NOT NULL DEFAULT FALSE,
    recurrence_rule JSONB CHECK (
        recurrence_rule IS NULL OR 
        (recurrence_rule ? 'frequency' AND recurrence_rule ? 'day_of_week')
    ),
    parent_recurrence_id UUID REFERENCES courses(id) ON DELETE SET NULL,
    
    -- Statut
    status VARCHAR(20) NOT NULL DEFAULT 'scheduled'
        CHECK (status IN ('scheduled', 'ongoing', 'completed', 'cancelled')),
    cancellation_reason TEXT,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index haute performance
CREATE INDEX idx_courses_organization_id ON courses(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_start_datetime ON courses(organization_id, start_datetime DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_coach_id ON courses(coach_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_status ON courses(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_parent_recurrence ON courses(parent_recurrence_id) WHERE parent_recurrence_id IS NOT NULL;
CREATE INDEX idx_courses_date_range ON courses(organization_id, start_datetime, end_datetime) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_recurrence_gin ON courses USING gin(recurrence_rule jsonb_path_ops) WHERE recurrence_rule IS NOT NULL;

-- Index pour recherches temporelles optimisées
CREATE INDEX idx_courses_upcoming ON courses(organization_id, start_datetime) 
    WHERE status = 'scheduled' AND deleted_at IS NULL;
CREATE INDEX idx_courses_past ON courses(organization_id, start_datetime DESC) 
    WHERE status = 'completed' AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE courses ENABLE ROW LEVEL SECURITY;

CREATE POLICY courses_isolation ON courses
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_courses_updated_at
    BEFORE UPDATE ON courses
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE courses IS 'Cours (ponctuels et récurrents avec occurrences)';
COMMENT ON COLUMN courses.recurrence_rule IS 'Règle de récurrence JSON: {frequency: "weekly", day_of_week: 1, end_date: "2026-06-30"}';
COMMENT ON COLUMN courses.parent_recurrence_id IS 'Lien vers le cours parent si occurrence de récurrence';


-- ============================================
-- TABLE: attendances (Présences et intentions)
-- ============================================
CREATE TABLE attendances (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    course_id UUID NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Intention (avant le cours)
    intention VARCHAR(20) CHECK (intention IN ('will_attend', 'will_not_attend') OR intention IS NULL),
    intention_at TIMESTAMP WITH TIME ZONE,
    
    -- Présence effective (pendant/après le cours)
    actual_attendance BOOLEAN,
    actual_attendance_at TIMESTAMP WITH TIME ZONE,
    
    -- Traçabilité
    marked_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    marked_by_role VARCHAR(20) CHECK (marked_by_role IN ('admin', 'coach', 'member') OR marked_by_role IS NULL),
    is_locked BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Notes
    notes TEXT,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contrainte unicité
    CONSTRAINT attendances_course_user_unique UNIQUE (course_id, user_id)
);

-- Index critiques pour performance
CREATE UNIQUE INDEX idx_attendances_course_user ON attendances(course_id, user_id);
CREATE INDEX idx_attendances_organization_id ON attendances(organization_id);
CREATE INDEX idx_attendances_user_id ON attendances(user_id);
CREATE INDEX idx_attendances_course_id ON attendances(course_id);

-- Index pour statistiques optimisées
CREATE INDEX idx_attendances_actual ON attendances(organization_id, user_id, actual_attendance) 
    WHERE actual_attendance IS NOT NULL;
CREATE INDEX idx_attendances_intention ON attendances(organization_id, course_id, intention) 
    WHERE intention IS NOT NULL;
CREATE INDEX idx_attendances_user_actual_date ON attendances(user_id, actual_attendance_at) 
    WHERE actual_attendance = TRUE;

-- Index composite pour requêtes fréquentes
CREATE INDEX idx_attendances_stats ON attendances(organization_id, user_id, actual_attendance, actual_attendance_at)
    WHERE actual_attendance IS NOT NULL;

-- Row Level Security
ALTER TABLE attendances ENABLE ROW LEVEL SECURITY;

CREATE POLICY attendances_isolation ON attendances
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_attendances_updated_at
    BEFORE UPDATE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE attendances IS 'Intentions et présences effectives aux cours';
COMMENT ON COLUMN attendances.intention IS 'Déclaration avant cours: will_attend ou will_not_attend';
COMMENT ON COLUMN attendances.actual_attendance IS 'Présence réelle: true = présent, false = absent, null = non encore marqué';
COMMENT ON COLUMN attendances.is_locked IS 'Verrouillage selon paramètre organisation';


-- ============================================
-- TABLE: subscriptions (Abonnements Stripe)
-- ============================================
CREATE TABLE subscriptions (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL UNIQUE REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Stripe
    stripe_customer_id VARCHAR(255) UNIQUE,
    stripe_subscription_id VARCHAR(255) UNIQUE,
    stripe_payment_method_id VARCHAR(255),
    
    -- Plan
    plan VARCHAR(20) NOT NULL CHECK (plan IN ('free', 'pro', 'premium')),
    status VARCHAR(20) NOT NULL 
        CHECK (status IN ('trialing', 'active', 'past_due', 'canceled', 'unpaid', 'incomplete')),
    
    -- Limites
    max_members INTEGER,
    features JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Dates
    current_period_start TIMESTAMP WITH TIME ZONE,
    current_period_end TIMESTAMP WITH TIME ZONE,
    trial_end TIMESTAMP WITH TIME ZONE,
    canceled_at TIMESTAMP WITH TIME ZONE,
    ended_at TIMESTAMP WITH TIME ZONE,
    
    -- Facturation
    amount_cents INTEGER CHECK (amount_cents >= 0),
    currency VARCHAR(3) NOT NULL DEFAULT 'EUR',
    interval VARCHAR(20) CHECK (interval IN ('month', 'year')),
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
CREATE INDEX idx_subscriptions_stripe_customer ON subscriptions(stripe_customer_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
CREATE INDEX idx_subscriptions_trial_end ON subscriptions(trial_end) WHERE trial_end IS NOT NULL;

-- Trigger
CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE subscriptions IS 'Abonnements et facturation Stripe';
COMMENT ON COLUMN subscriptions.features IS 'Fonctionnalités actives selon plan';


-- ============================================
-- TABLE: custom_fields (Champs personnalisés)
-- ============================================
CREATE TABLE custom_fields (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Définition
    field_name VARCHAR(100) NOT NULL,
    field_key VARCHAR(50) NOT NULL CHECK (field_key ~ '^[a-z_]+$'),
    field_type VARCHAR(20) NOT NULL 
        CHECK (field_type IN ('text', 'number', 'date', 'boolean', 'select', 'multi_select')),
    field_options JSONB DEFAULT '{}'::jsonb,
    
    -- Comportement
    is_required BOOLEAN NOT NULL DEFAULT FALSE,
    show_in_stats BOOLEAN NOT NULL DEFAULT FALSE,
    display_order INTEGER NOT NULL DEFAULT 0,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Contrainte unicité
    CONSTRAINT custom_fields_org_key_unique UNIQUE (organization_id, field_key)
);

-- Index
CREATE INDEX idx_custom_fields_organization ON custom_fields(organization_id, display_order) 
    WHERE deleted_at IS NULL;
CREATE INDEX idx_custom_fields_stats ON custom_fields(organization_id) 
    WHERE show_in_stats = TRUE AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE custom_fields ENABLE ROW LEVEL SECURITY;

CREATE POLICY custom_fields_isolation ON custom_fields
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_custom_fields_updated_at
    BEFORE UPDATE ON custom_fields
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE custom_fields IS 'Définition des champs personnalisés par organisation';
COMMENT ON COLUMN custom_fields.field_options IS 'Options JSON: {values: ["Option1", "Option2"]} pour select';


-- ============================================
-- TABLE: audit_logs (Traçabilité)
-- ============================================
CREATE TABLE audit_logs (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Qui
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    user_email VARCHAR(255),
    user_role VARCHAR(20),
    
    -- Quoi
    action VARCHAR(100) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID,
    
    -- Détails
    changes JSONB DEFAULT '{}'::jsonb,
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contexte
    ip_address INET,
    user_agent TEXT,
    
    -- Quand
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index pour requêtes fréquentes
CREATE INDEX idx_audit_logs_organization ON audit_logs(organization_id, created_at DESC);
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_entity ON audit_logs(entity_type, entity_id);
CREATE INDEX idx_audit_logs_created ON audit_logs(created_at DESC);

-- Partitionnement par date (recommandé si gros volume)
-- CREATE TABLE audit_logs_2025_10 PARTITION OF audit_logs
--     FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');

-- Row Level Security
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY audit_logs_isolation ON audit_logs
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Commentaires
COMMENT ON TABLE audit_logs IS 'Logs de toutes les actions utilisateurs (traçabilité complète)';
COMMENT ON COLUMN audit_logs.changes IS 'Changements JSON: {before: {...}, after: {...}}';


-- ============================================
-- VUES MATÉRIALISÉES (Performance)
-- ============================================

-- Vue: Statistiques adhérents pré-calculées
CREATE MATERIALIZED VIEW mv_member_stats AS
SELECT 
    u.id AS user_id,
    u.organization_id,
    u.first_name,
    u.last_name,
    COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled') AS available_courses,
    ROUND(
        (COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE)::numeric / 
        NULLIF(COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled'), 0)) * 100, 
        2
    ) AS attendance_rate,
    MAX(a.actual_attendance_at) AS last_attendance_date,
    CURRENT_DATE - MAX(a.actual_attendance_at)::date AS days_since_last_attendance
FROM users u
LEFT JOIN attendances a ON u.id = a.user_id
LEFT JOIN courses c ON a.course_id = c.id
WHERE u.deleted_at IS NULL 
    AND u.role = 'member'
    AND c.start_datetime >= CURRENT_DATE - INTERVAL '3 months'
GROUP BY u.id, u.organization_id, u.first_name, u.last_name;

-- Index sur vue matérialisée
CREATE UNIQUE INDEX idx_mv_member_stats_user ON mv_member_stats(user_id);
CREATE INDEX idx_mv_member_stats_org ON mv_member_stats(organization_id);
CREATE INDEX idx_mv_member_stats_rate ON mv_member_stats(organization_id, attendance_rate DESC);

-- Commentaire
COMMENT ON MATERIALIZED VIEW mv_member_stats IS 'Stats adhérents pré-calculées (refresh quotidien recommandé)';

-- Fonction de refresh automatique (à scheduler)
CREATE OR REPLACE FUNCTION refresh_member_stats()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_stats;
END;
$$ LANGUAGE plpgsql;


-- ============================================
-- FONCTIONS UTILITAIRES
-- ============================================

-- Fonction: Définir le tenant courant (pour RLS)
CREATE OR REPLACE FUNCTION set_current_tenant(tenant_id UUID)
RETURNS void AS $$
BEGIN
    PERFORM set_config('app.current_tenant', tenant_id::text, false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION set_current_tenant IS 'Définit le tenant courant pour Row Level Security';


-- Fonction: Calculer le taux de présence d'un adhérent
CREATE OR REPLACE FUNCTION calculate_attendance_rate(
    p_user_id UUID,
    p_start_date TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_end_date TIMESTAMP WITH TIME ZONE DEFAULT NULL
)
RETURNS NUMERIC AS $$
DECLARE
    v_attendances INTEGER;
    v_available_courses INTEGER;
BEGIN
    -- Compte les présences effectives
    SELECT COUNT(*) INTO v_attendances
    FROM attendances a
    INNER JOIN courses c ON a.course_id = c.id
    WHERE a.user_id = p_user_id
        AND a.actual_attendance = TRUE
        AND (p_start_date IS NULL OR c.start_datetime >= p_start_date)
        AND (p_end_date IS NULL OR c.start_datetime <= p_end_date);
    
    -- Compte les cours disponibles (non annulés)
    SELECT COUNT(DISTINCT c.id) INTO v_available_courses
    FROM courses c
    WHERE c.organization_id = (SELECT organization_id FROM users WHERE id = p_user_id)
        AND c.status != 'cancelled'
        AND (p_start_date IS NULL OR c.start_datetime >= p_start_date)
        AND (p_end_date IS NULL OR c.start_datetime <= p_end_date);
    
    -- Calcul du taux
    IF v_available_courses = 0 THEN
        RETURN 0;
    END IF;
    
    RETURN ROUND((v_attendances::numeric / v_available_courses) * 100, 2);
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION calculate_attendance_rate IS 'Calcule le taux de présence d''un adhérent sur une période';


-- Fonction: Détecter les adhérents à risque d'abandon
CREATE OR REPLACE FUNCTION detect_at_risk_members(
    p_organization_id UUID,
    p_days_threshold INTEGER DEFAULT 21
)
RETURNS TABLE (
    user_id UUID,
    user_name TEXT,
    days_absent INTEGER,
    previous_rate NUMERIC,
    risk_level TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.id,
        u.first_name || ' ' || u.last_name,
        CURRENT_DATE - MAX(a.actual_attendance_at)::date,
        calculate_attendance_rate(u.id, CURRENT_DATE - INTERVAL '3 months', CURRENT_DATE - INTERVAL '1 month'),
        CASE 
            WHEN CURRENT_DATE - MAX(a.actual_attendance_at)::date >= 30 THEN 'critical'
            WHEN CURRENT_DATE - MAX(a.actual_attendance_at)::date >= p_days_threshold THEN 'warning'
            ELSE 'normal'
        END
    FROM users u
    LEFT JOIN attendances a ON u.id = a.user_id AND a.actual_attendance = TRUE
    WHERE u.organization_id = p_organization_id
        AND u.role = 'member'
        AND u.status = 'active'
        AND u.deleted_at IS NULL
    GROUP BY u.id, u.first_name, u.last_name
    HAVING MAX(a.actual_attendance_at) IS NOT NULL
        AND CURRENT_DATE - MAX(a.actual_attendance_at)::date >= p_days_threshold
    ORDER BY CURRENT_DATE - MAX(a.actual_attendance_at)::date DESC;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION detect_at_risk_members IS 'Détecte les adhérents absents depuis X jours (risque abandon)';


-- ============================================
-- TRIGGERS AVANCÉS
-- ============================================

-- Trigger: Auto-update subscription_status dans organizations
CREATE OR REPLACE FUNCTION sync_subscription_status()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE organizations 
    SET subscription_status = NEW.status
    WHERE id = NEW.organization_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_subscription_to_org
    AFTER INSERT OR UPDATE OF status ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION sync_subscription_status();


-- Trigger: Audit automatique sur modifications importantes
CREATE OR REPLACE FUNCTION log_important_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_logs (
            organization_id,
            user_id,
            action,
            entity_type,
            entity_id,
            changes
        ) VALUES (
            NEW.organization_id,
            current_setting('app.current_user_id', true)::uuid,
            TG_TABLE_NAME || '.updated',
            TG_TABLE_NAME,
            NEW.id,
            jsonb_build_object('before', to_jsonb(OLD), 'after', to_jsonb(NEW))
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_logs (
            organization_id,
            user_id,
            action,
            entity_type,
            entity_id,
            changes
        ) VALUES (
            OLD.organization_id,
            current_setting('app.current_user_id', true)::uuid,
            TG_TABLE_NAME || '.deleted',
            TG_TABLE_NAME,
            OLD.id,
            jsonb_build_object('before', to_jsonb(OLD))
        );
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Appliquer l'audit sur les tables critiques
CREATE TRIGGER audit_courses_changes
    AFTER UPDATE OR DELETE ON courses
    FOR EACH ROW
    EXECUTE FUNCTION log_important_changes();

CREATE TRIGGER audit_attendances_changes
    AFTER UPDATE OR DELETE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION log_important_changes();


-- ============================================
-- CONTRAINTES D'INTÉGRITÉ AVANCÉES
-- ============================================

-- Vérifier que le coach appartient à l'organisation
ALTER TABLE courses ADD CONSTRAINT check_coach_organization
    CHECK (
        coach_id IS NULL OR 
        EXISTS (
            SELECT 1 FROM users 
            WHERE id = coach_id 
            AND organization_id = courses.organization_id
            AND role IN ('coach', 'admin')
        )
    );

-- Vérifier cohérence des dates de récurrence
ALTER TABLE courses ADD CONSTRAINT check_recurrence_dates
    CHECK (
        NOT is_recurring OR 
        (recurrence_rule IS NOT NULL)
    );


-- ============================================
-- GRANTS ET SÉCURITÉ
-- ============================================

-- Rôle application (utilisé par le backend)
CREATE ROLE app_user WITH LOGIN PASSWORD 'change_me_in_production';

-- Permissions strictes
GRANT CONNECT ON DATABASE postgres TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO app_user;

-- Lecture seule pour les rapports
CREATE ROLE app_readonly WITH LOGIN PASSWORD 'change_me_readonly';
GRANT CONNECT ON DATABASE postgres TO app_readonly;
GRANT USAGE ON SCHEMA public TO app_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_readonly;


-- ============================================
-- DONNÉES DE TEST (Optionnel)
-- ============================================

-- Insertion organisation de test
INSERT INTO organizations (id, name, slug, email, subscription_plan, subscription_status)
VALUES (
    'a0000000-0000-0000-0000-000000000001',
    'Krav Maga Lyon Centre',
    'krav-maga-lyon-centre',
    'contact@kravlyon.fr',
    'pro',
    'active'
);

-- Insertion utilisateurs de test
INSERT INTO users (organization_id, email, password_hash, first_name, last_name, role)
VALUES 
    ('a0000000-0000-0000-0000-000000000001', 'admin@kravlyon.fr', '$2b$12$dummy_hash', 'Sophie', 'Bernard', 'admin'),
    ('a0000000-0000-0000-0000-000000000001', 'marc@kravlyon.fr', '$2b$12$dummy_hash', 'Marc', 'Petit', 'coach'),
    ('a0000000-0000-0000-0000-000000000001', 'lisa@email.com', '$2b$12$dummy_hash', 'Lisa', 'Martin', 'member');


-- ============================================
-- MAINTENANCE ET MONITORING
-- ============================================

-- ============================================
-- MAINTENANCE ET MONITORING
-- ============================================

-- Vue pour monitoring des performances
CREATE VIEW v_table_sizes AS
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) AS indexes_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

COMMENT ON VIEW v_table_sizes IS 'Taille des tables et indexes pour monitoring';


-- Vue pour monitoring des index inutilisés
CREATE VIEW v_unused_indexes AS
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
    AND indexrelname NOT LIKE 'pg_toast%'
    AND schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;

COMMENT ON VIEW v_unused_indexes IS 'Index jamais utilisés (candidats pour suppression)';


-- Vue pour monitoring des connexions actives
CREATE VIEW v_active_connections AS
SELECT 
    datname,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change,
    wait_event_type,
    wait_event,
    LEFT(query, 100) AS query_preview
FROM pg_stat_activity
WHERE datname = current_database()
    AND pid != pg_backend_pid()
ORDER BY query_start;

COMMENT ON VIEW v_active_connections IS 'Connexions actives à la base de données';


-- Vue pour statistiques par organisation
CREATE VIEW v_organization_stats AS
SELECT 
    o.id,
    o.name,
    o.subscription_plan,
    COUNT(DISTINCT u.id) FILTER (WHERE u.role = 'member' AND u.deleted_at IS NULL) AS total_members,
    COUNT(DISTINCT u.id) FILTER (WHERE u.role = 'coach' AND u.deleted_at IS NULL) AS total_coaches,
    COUNT(DISTINCT c.id) FILTER (WHERE c.deleted_at IS NULL) AS total_courses,
    COUNT(DISTINCT a.id) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    ROUND(
        AVG(
            (SELECT calculate_attendance_rate(u2.id, CURRENT_DATE - INTERVAL '30 days', CURRENT_DATE)
             FROM users u2 
             WHERE u2.organization_id = o.id AND u2.role = 'member' AND u2.deleted_at IS NULL)
        ), 2
    ) AS avg_attendance_rate_30d
FROM organizations o
LEFT JOIN users u ON o.id = u.organization_id
LEFT JOIN courses c ON o.id = c.organization_id
LEFT JOIN attendances a ON o.id = a.organization_id
WHERE o.deleted_at IS NULL
GROUP BY o.id, o.name, o.subscription_plan;

COMMENT ON VIEW v_organization_stats IS 'Statistiques agrégées par organisation';


-- ============================================
-- PROCÉDURES DE MAINTENANCE
-- ============================================

-- Procédure: Nettoyage des données obsolètes
CREATE OR REPLACE PROCEDURE cleanup_old_data(
    p_audit_logs_retention_days INTEGER DEFAULT 365,
    p_deleted_records_retention_days INTEGER DEFAULT 90
)
LANGUAGE plpgsql
AS $
BEGIN
    -- Supprimer les vieux logs d'audit
    DELETE FROM audit_logs 
    WHERE created_at < CURRENT_DATE - (p_audit_logs_retention_days || ' days')::INTERVAL;
    
    RAISE NOTICE 'Audit logs nettoyés: % lignes supprimées', 
        (SELECT count(*) FROM audit_logs WHERE created_at < CURRENT_DATE - (p_audit_logs_retention_days || ' days')::INTERVAL);
    
    -- Supprimer définitivement les enregistrements soft-deleted anciens
    DELETE FROM users 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    DELETE FROM courses 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    DELETE FROM organizations 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    RAISE NOTICE 'Nettoyage terminé';
END;
$;

COMMENT ON PROCEDURE cleanup_old_data IS 'Nettoyage automatique des données obsolètes (à scheduler)';


-- Procédure: Vacuum et analyse automatiques
CREATE OR REPLACE PROCEDURE maintenance_vacuum_analyze()
LANGUAGE plpgsql
AS $
BEGIN
    VACUUM ANALYZE organizations;
    VACUUM ANALYZE users;
    VACUUM ANALYZE courses;
    VACUUM ANALYZE attendances;
    VACUUM ANALYZE subscriptions;
    VACUUM ANALYZE custom_fields;
    VACUUM ANALYZE audit_logs;
    
    RAISE NOTICE 'Vacuum et analyse terminés';
END;
$;

COMMENT ON PROCEDURE maintenance_vacuum_analyze IS 'Vacuum et analyse des tables principales (à scheduler quotidiennement)';


-- Procédure: Refresh des vues matérialisées
CREATE OR REPLACE PROCEDURE refresh_all_materialized_views()
LANGUAGE plpgsql
AS $
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_stats;
    RAISE NOTICE 'Vues matérialisées rafraîchies';
END;
$;

COMMENT ON PROCEDURE refresh_all_materialized_views IS 'Rafraîchissement de toutes les vues matérialisées (à scheduler quotidiennement)';


-- ============================================
-- BACKUP ET RESTORE
-- ============================================

-- Fonction: Export des données d'une organisation (RGPD)
CREATE OR REPLACE FUNCTION export_organization_data(p_organization_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $
DECLARE
    v_data JSONB;
BEGIN
    SELECT jsonb_build_object(
        'organization', (SELECT row_to_json(o.*) FROM organizations o WHERE id = p_organization_id),
        'users', (SELECT jsonb_agg(row_to_json(u.*)) FROM users u WHERE organization_id = p_organization_id AND deleted_at IS NULL),
        'courses', (SELECT jsonb_agg(row_to_json(c.*)) FROM courses c WHERE organization_id = p_organization_id AND deleted_at IS NULL),
        'attendances', (SELECT jsonb_agg(row_to_json(a.*)) FROM attendances a WHERE organization_id = p_organization_id),
        'custom_fields', (SELECT jsonb_agg(row_to_json(cf.*)) FROM custom_fields cf WHERE organization_id = p_organization_id AND deleted_at IS NULL)
    ) INTO v_data;
    
    RETURN v_data;
END;
$;

COMMENT ON FUNCTION export_organization_data IS 'Export complet des données d''une organisation (conformité RGPD)';


-- Fonction: Anonymisation d'un utilisateur (RGPD - droit à l'oubli)
CREATE OR REPLACE FUNCTION anonymize_user(p_user_id UUID)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $
BEGIN
    UPDATE users
    SET 
        email = 'deleted_' || id || '@anonymized.local',
        first_name = 'Utilisateur',
        last_name = '[Supprimé]',
        phone = NULL,
        date_of_birth = NULL,
        metadata = '{}'::jsonb,
        password_hash = 'ANONYMIZED',
        deleted_at = CURRENT_TIMESTAMP
    WHERE id = p_user_id;
    
    -- Log de l'action
    INSERT INTO audit_logs (
        organization_id,
        user_id,
        action,
        entity_type,
        entity_id,
        metadata
    ) VALUES (
        (SELECT organization_id FROM users WHERE id = p_user_id),
        p_user_id,
        'user.anonymized',
        'users',
        p_user_id,
        jsonb_build_object('anonymized_at', CURRENT_TIMESTAMP, 'reason', 'RGPD_right_to_be_forgotten')
    );
    
    RAISE NOTICE 'Utilisateur % anonymisé', p_user_id;
END;
$;

COMMENT ON FUNCTION anonymize_user IS 'Anonymisation d''un utilisateur (RGPD - droit à l''oubli)';


-- ============================================
-- INDEXES PARTIELS AVANCÉS (Optimisation)
-- ============================================

-- Index pour les cours à venir uniquement (requête très fréquente)
CREATE INDEX idx_courses_upcoming_detailed ON courses(organization_id, start_datetime, status)
    WHERE start_datetime > CURRENT_TIMESTAMP 
        AND status = 'scheduled' 
        AND deleted_at IS NULL;

-- Index pour les adhérents actifs récents
CREATE INDEX idx_users_active_recent ON users(organization_id, last_login_at DESC)
    WHERE status = 'active' 
        AND deleted_at IS NULL
        AND last_login_at > CURRENT_TIMESTAMP - INTERVAL '30 days';

-- Index pour présences du mois en cours (statistiques temps réel)
CREATE INDEX idx_attendances_current_month ON attendances(organization_id, user_id, actual_attendance)
    WHERE actual_attendance_at >= date_trunc('month', CURRENT_DATE)
        AND actual_attendance IS NOT NULL;


-- ============================================
-- POLICIES RLS AVANCÉES (Sécurité fine)
-- ============================================

-- Policy: Les coachs ne voient que leurs cours
CREATE POLICY coaches_own_courses ON courses
    FOR SELECT
    USING (
        organization_id = current_setting('app.current_tenant', true)::uuid
        AND (
            coach_id = current_setting('app.current_user_id', true)::uuid
            OR EXISTS (
                SELECT 1 FROM users 
                WHERE id = current_setting('app.current_user_id', true)::uuid 
                AND role IN ('admin')
            )
        )
    );

-- Policy: Les adhérents ne voient que leurs propres présences détaillées
CREATE POLICY members_own_attendances ON attendances
    FOR SELECT
    USING (
        organization_id = current_setting('app.current_tenant', true)::uuid
        AND (
            user_id = current_setting('app.current_user_id', true)::uuid
            OR EXISTS (
                SELECT 1 FROM users 
                WHERE id = current_setting('app.current_user_id', true)::uuid 
                AND role IN ('admin', 'coach')
            )
        )
    );


-- ============================================
-- CONTRAINTES DE VALIDATION MÉTIER
-- ============================================

-- Vérifier qu'un cours ne dépasse pas 24h
ALTER TABLE courses ADD CONSTRAINT check_course_max_duration
    CHECK (end_datetime - start_datetime <= INTERVAL '24 hours');

-- Vérifier qu'on ne peut pas marquer présent à un cours dans le futur
CREATE OR REPLACE FUNCTION check_attendance_not_future()
RETURNS TRIGGER AS $
BEGIN
    IF NEW.actual_attendance IS NOT NULL AND NEW.actual_attendance_at IS NOT NULL THEN
        IF NEW.actual_attendance_at > (SELECT end_datetime FROM courses WHERE id = NEW.course_id) + INTERVAL '2 hours' THEN
            RAISE EXCEPTION 'Impossible de marquer une présence plus de 2h après la fin du cours';
        END IF;
    END IF;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER validate_attendance_timing
    BEFORE INSERT OR UPDATE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION check_attendance_not_future();


-- ============================================
-- FONCTIONS D'AGRÉGATION PERSONNALISÉES
-- ============================================

-- Fonction: Statistiques complètes d'un adhérent
CREATE OR REPLACE FUNCTION get_member_complete_stats(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $
DECLARE
    v_stats JSONB;
BEGIN
    SELECT jsonb_build_object(
        'user_id', p_user_id,
        'total_courses_available', (
            SELECT COUNT(*) 
            FROM courses c
            WHERE c.organization_id = (SELECT organization_id FROM users WHERE id = p_user_id)
                AND c.status != 'cancelled'
                AND c.start_datetime >= (SELECT join_date FROM users WHERE id = p_user_id)
                AND c.deleted_at IS NULL
        ),
        'total_attendances', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'attendance_rate', calculate_attendance_rate(p_user_id),
        'attendance_rate_30d', calculate_attendance_rate(p_user_id, CURRENT_DATE - INTERVAL '30 days', CURRENT_DATE),
        'attendance_rate_90d', calculate_attendance_rate(p_user_id, CURRENT_DATE - INTERVAL '90 days', CURRENT_DATE),
        'last_attendance', (
            SELECT MAX(actual_attendance_at) 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'days_since_last_attendance', (
            SELECT CURRENT_DATE - MAX(actual_attendance_at)::date 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'current_streak', (
            -- Série de présences consécutives (simplifié)
            SELECT COUNT(*)
            FROM attendances a
            INNER JOIN courses c ON a.course_id = c.id
            WHERE a.user_id = p_user_id 
                AND a.actual_attendance = TRUE
                AND c.start_datetime >= CURRENT_DATE - INTERVAL '30 days'
        ),
        'total_intentions', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE user_id = p_user_id AND intention = 'will_attend'
        ),
        'intention_reliability', (
            -- Fiabilité des inscriptions
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE intention = 'will_attend' AND actual_attendance = TRUE)::numeric /
                NULLIF(COUNT(*) FILTER (WHERE intention = 'will_attend'), 0)) * 100, 2
            )
            FROM attendances
            WHERE user_id = p_user_id
        )
    ) INTO v_stats;
    
    RETURN v_stats;
END;
$;

COMMENT ON FUNCTION get_member_complete_stats IS 'Statistiques complètes d''un adhérent (toutes périodes)';


-- Fonction: Statistiques d'un cours
CREATE OR REPLACE FUNCTION get_course_stats(p_course_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $
DECLARE
    v_stats JSONB;
BEGIN
    SELECT jsonb_build_object(
        'course_id', p_course_id,
        'total_enrolled', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE course_id = p_course_id AND intention = 'will_attend'
        ),
        'total_attended', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE course_id = p_course_id AND actual_attendance = TRUE
        ),
        'occupancy_rate', (
            SELECT CASE 
                WHEN c.max_capacity IS NOT NULL THEN
                    ROUND((COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE)::numeric / c.max_capacity) * 100, 2)
                ELSE NULL
            END
            FROM courses c
            LEFT JOIN attendances a ON c.id = a.course_id
            WHERE c.id = p_course_id
            GROUP BY c.max_capacity
        ),
        'no_show_rate', (
            -- Taux de non-présentation (inscrits mais absents)
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE intention = 'will_attend' AND actual_attendance = FALSE)::numeric /
                NULLIF(COUNT(*) FILTER (WHERE intention = 'will_attend'), 0)) * 100, 2
            )
            FROM attendances
            WHERE course_id = p_course_id
        ),
        'walk_ins', (
            -- Présents non-inscrits
            SELECT COUNT(*)
            FROM attendances
            WHERE course_id = p_course_id 
                AND intention IS NULL 
                AND actual_attendance = TRUE
        )
    ) INTO v_stats;
    
    RETURN v_stats;
END;
$;

COMMENT ON FUNCTION get_course_stats IS 'Statistiques détaillées d''un cours';


-- ============================================
-- SCHEDULING (À configurer via pg_cron ou cron externe)
-- ============================================

-- Extension pg_cron (optionnelle, nécessite installation)
-- CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Exemples de tâches planifiées (à décommenter si pg_cron installé)
/*
-- Refresh des stats quotidien à 2h du matin
SELECT cron.schedule('refresh-stats', '0 2 * * *', $
    CALL refresh_all_materialized_views();
$);

-- Nettoyage hebdomadaire le dimanche à 3h
SELECT cron.schedule('cleanup-old-data', '0 3 * * 0', $
    CALL cleanup_old_data(365, 90);
$);

-- Vacuum quotidien à 4h
SELECT cron.schedule('daily-vacuum', '0 4 * * *', $
    CALL maintenance_vacuum_analyze();
$);
*/


-- ============================================
-- DOCUMENTATION FINALE
-- ============================================

COMMENT ON DATABASE postgres IS 'KravStats - Application de gestion de présences sportives multi-tenant';

-- Documentation des conventions
/*
CONVENTIONS DE NOMMAGE:
- Tables: pluriel, snake_case (ex: users, courses, attendances)
- Colonnes: snake_case (ex: first_name, created_at)
- Index: idx_tablename_columns (ex: idx_users_email_org)
- Contraintes: check_tablename_description (ex: check_course_max_duration)
- Fonctions: verbe_nom (ex: calculate_attendance_rate)
- Vues matérialisées: mv_description (ex: mv_member_stats)
- Triggers: nom_action (ex: update_users_updated_at)

TYPES DE DONNÉES:
- ID: UUID (sécurité, distribution)
- Dates: TIMESTAMP WITH TIME ZONE (internationalisation)
- Textes courts: VARCHAR avec limite
- Textes longs: TEXT
- Booléens: BOOLEAN (jamais NULL si logique binaire)
- Montants: INTEGER en centimes (éviter DECIMAL pour les montants)
- Données flexibles: JSONB (indexable avec GIN)

SÉCURITÉ:
- Row Level Security (RLS) activé sur toutes les tables multi-tenant
- Soft delete (deleted_at) pour traçabilité
- Audit logs pour actions critiques
- Contraintes CHECK pour validation côté DB
- SECURITY DEFINER pour fonctions sensibles

PERFORMANCE:
- Index partiels (WHERE) pour requêtes fréquentes
- Index composites pour requêtes complexes
- Vues matérialisées pour agrégations coûteuses
- Index GIN pour JSONB
- Contraintes de clés étrangères avec ON DELETE CASCADE/SET NULL

MAINTENANCE:
- Vacuum automatique (configurer autovacuum)
- Refresh vues matérialisées quotidien
- Nettoyage logs > 1 an
- Monitoring taille tables/index
- Backup quotidien (pg_dump ou solution cloud)

SCALABILITÉ:
- Partitionnement par date pour audit_logs si > 10M lignes
- Connection pooling (PgBouncer) recommandé
- Read replicas pour reporting (PostgreSQL streaming replication)
- Sharding par organization_id si > 1000 tenants
*/


-- ============================================
-- FIN DU SCHÉMA
-- ============================================

-- Afficher un résumé
DO $
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Schéma de base de données créé avec succès';
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Tables créées: %', (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_type = 'BASE TABLE');
    RAISE NOTICE 'Index créés: %', (SELECT COUNT(*) FROM pg_indexes WHERE schemaname = 'public');
    RAISE NOTICE 'Fonctions créées: %', (SELECT COUNT(*) FROM pg_proc WHERE pronamespace = 'public'::regnamespace);
    RAISE NOTICE 'Triggers créés: %', (SELECT COUNT(*) FROM pg_trigger WHERE tgrelid IN (SELECT oid FROM pg_class WHERE relnamespace = 'public'::regnamespace));
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Prochaines étapes:';
    RAISE NOTICE '1. Configurer les variables d''environnement';
    RAISE NOTICE '2. Créer les rôles app_user et app_readonly';
    RAISE NOTICE '3. Configurer pg_cron ou cron système pour maintenance';
    RAISE NOTICE '4. Configurer les backups automatiques';
    RAISE NOTICE '5. Tester les fonctions avec données de test';
    RAISE NOTICE '========================================';
END $;),
    field_type VARCHAR(20) NOT NULL 
        CHECK (field_type IN ('text', 'number', 'date', 'boolean', 'select', 'multi_select')),
    field_options JSONB DEFAULT '{}'::jsonb,
    
    -- Comportement
    is_required BOOLEAN NOT NULL DEFAULT FALSE,
    show_in_stats BOOLEAN NOT NULL DEFAULT FALSE,
    display_order INTEGER NOT NULL DEFAULT 0,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Contrainte unicité
    CONSTRAINT custom_fields_org_key_unique UNIQUE (organization_id, field_key)
);

-- Index
CREATE INDEX idx_custom_fields_organization ON custom_fields(organization_id, display_order) 
    WHERE deleted_at IS NULL;
CREATE INDEX idx_custom_fields_stats ON custom_fields(organization_id) 
    WHERE show_in_stats = TRUE AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE custom_fields ENABLE ROW LEVEL SECURITY;

CREATE POLICY custom_fields_isolation ON custom_fields
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_custom_fields_updated_at
    BEFORE UPDATE ON custom_fields
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE custom_fields IS 'Définition des champs personnalisés par organisation';
COMMENT ON COLUMN custom_fields.field_options IS 'Options JSON: {values: ["Option1", "Option2"]} pour select';


-- ============================================
-- TABLE: audit_logs (Traçabilité)
-- PARTITIONNÉE PAR MOIS POUR PERFORMANCE
-- ============================================
CREATE TABLE audit_logs (
    -- Clés
    id UUID DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Qui
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    user_email VARCHAR(255),
    user_role VARCHAR(20),
    
    -- Quoi
    action VARCHAR(100) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID,
    
    -- Détails
    changes JSONB DEFAULT '{}'::jsonb,
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contexte
    ip_address INET,
    user_agent TEXT,
    
    -- Quand
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (created_at);

-- Créer les partitions pour 2025 (à étendre annuellement)
CREATE TABLE audit_logs_2025_10 PARTITION OF audit_logs
    FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');
CREATE TABLE audit_logs_2025_11 PARTITION OF audit_logs
    FOR VALUES FROM ('2025-11-01') TO ('2025-12-01');
CREATE TABLE audit_logs_2025_12 PARTITION OF audit_logs
    FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

-- Index pour requêtes fréquentes (sur partition principale)
CREATE INDEX idx_audit_logs_organization ON audit_logs(organization_id, created_at DESC);
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_entity ON audit_logs(entity_type, entity_id);

-- Row Level Security
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY audit_logs_isolation ON audit_logs
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Commentaires
COMMENT ON TABLE audit_logs IS 'Logs d''audit PARTITIONNÉ par mois pour performance analytics';


-- ============================================
-- TABLE DIMENSION: dim_date (POUR ANALYTICS)
-- Table calendrier pré-générée
-- ============================================
CREATE TABLE dim_date (
    date_id SERIAL PRIMARY KEY,
    date DATE UNIQUE NOT NULL,
    year INTEGER NOT NULL,
    quarter INTEGER NOT NULL,
    month INTEGER NOT NULL,
    month_name VARCHAR(20) NOT NULL,
    week_of_year INTEGER NOT NULL,
    day_of_month INTEGER NOT NULL,
    day_of_week INTEGER NOT NULL, -- 1=Lundi, 7=Dimanche
    day_name VARCHAR(20) NOT NULL,
    is_weekend BOOLEAN NOT NULL,
    is_holiday BOOLEAN DEFAULT FALSE,
    holiday_name VARCHAR(100),
    season VARCHAR(20) -- 'winter', 'spring', 'summer', 'fall'
);

-- Index
CREATE INDEX idx_dim_date_year_month ON dim_date(year, month);
CREATE INDEX idx_dim_date_year_week ON dim_date(year, week_of_year);
CREATE INDEX idx_dim_date_dow ON dim_date(day_of_week);

-- Fonction pour peupler dim_date
CREATE OR REPLACE FUNCTION populate_dim_date(
    start_date DATE DEFAULT '2025-01-01',
    end_date DATE DEFAULT '2030-12-31'
)
RETURNS void AS $
DECLARE
    current_date DATE := start_date;
BEGIN
    WHILE current_date <= end_date LOOP
        INSERT INTO dim_date (
            date,
            year,
            quarter,
            month,
            month_name,
            week_of_year,
            day_of_month,
            day_of_week,
            day_name,
            is_weekend,
            season
        ) VALUES (
            current_date,
            EXTRACT(YEAR FROM current_date),
            EXTRACT(QUARTER FROM current_date),
            EXTRACT(MONTH FROM current_date),
            TO_CHAR(current_date, 'Month'),
            EXTRACT(WEEK FROM current_date),
            EXTRACT(DAY FROM current_date),
            EXTRACT(ISODOW FROM current_date),
            TO_CHAR(current_date, 'Day'),
            EXTRACT(ISODOW FROM current_date) IN (6, 7),
            CASE 
                WHEN EXTRACT(MONTH FROM current_date) IN (12, 1, 2) THEN 'winter'
                WHEN EXTRACT(MONTH FROM current_date) IN (3, 4, 5) THEN 'spring'
                WHEN EXTRACT(MONTH FROM current_date) IN (6, 7, 8) THEN 'summer'
                ELSE 'fall'
            END
        )
        ON CONFLICT (date) DO NOTHING;
        
        current_date := current_date + INTERVAL '1 day';
    END LOOP;
END;
$ LANGUAGE plpgsql;

-- Peupler la table
SELECT populate_dim_date('2024-01-01', '2027-12-31');

COMMENT ON TABLE dim_date IS 'TABLE DIMENSION calendrier pour analyses temporelles (data warehouse pattern)';


-- ============================================
-- VUES MATÉRIALISÉES ANALYTICS
-- ============================================

-- Vue: Statistiques adhérents pré-calculées (refresh quotidien)
CREATE MATERIALIZED VIEW mv_member_stats AS
SELECT 
    u.id AS user_id,
    u.organization_id,
    u.first_name,
    u.last_name,
    u.metadata->>'belt_level' AS belt_level,
    COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled') AS available_courses,
    ROUND(
        (COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE)::numeric / 
        NULLIF(COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled'), 0)) * 100, 
        2
    ) AS attendance_rate,
    MAX(a.actual_attendance_at) AS last_attendance_date,
    CURRENT_DATE - MAX(a.actual_attendance_at)::date AS days_since_last_attendance,
    -- Métriques fiabilité
    COUNT(a.id) FILTER (WHERE a.is_reliable = TRUE) AS reliable_count,
    COUNT(a.id) FILTER (WHERE a.is_no_show = TRUE) AS no_show_count,
    COUNT(a.id) FILTER (WHERE a.is_walk_in = TRUE) AS walk_in_count,
    ROUND(
        (COUNT(a.id) FILTER (WHERE a.is_reliable = TRUE)::numeric /
        NULLIF(COUNT(a.id) FILTER (WHERE a.intention = 'will_attend'), 0)) * 100,
        2
    ) AS reliability_rate
FROM users u
LEFT JOIN attendances a ON u.id = a.user_id
LEFT JOIN courses c ON a.course_id = c.id
WHERE u.deleted_at IS NULL 
    AND u.role = 'member'
    AND c.start_datetime >= CURRENT_DATE - INTERVAL '3 months'
GROUP BY u.id, u.organization_id, u.first_name, u.last_name, u.metadata->>'belt_level';

-- Index sur vue matérialisée
CREATE UNIQUE INDEX idx_mv_member_stats_user ON mv_member_stats(user_id);
CREATE INDEX idx_mv_member_stats_org ON mv_member_stats(organization_id);
CREATE INDEX idx_mv_member_stats_rate ON mv_member_stats(organization_id, attendance_rate DESC);
CREATE INDEX idx_mv_member_stats_belt ON mv_member_stats(organization_id, belt_level) WHERE belt_level IS NOT NULL;

COMMENT ON MATERIALIZED VIEW mv_member_stats IS 'Stats adhérents pré-calculées avec métriques fiabilité';


-- Vue: Statistiques cours agrégées
CREATE MATERIALIZED VIEW mv_course_stats AS
SELECT
    c.id AS course_id,
    c.organization_id,
    c.title,
    c.course_type,
    c.day_of_week,
    c.month,
    c.year,
    COUNT(DISTINCT a.user_id) FILTER (WHERE a.intention = 'will_attend') AS enrolled_count,
    COUNT(DISTINCT a.user_id) FILTER (WHERE a.actual_attendance = TRUE) AS attended_count,
    ROUND(
        (COUNT(DISTINCT a.user_id) FILTER (WHERE a.actual_attendance = TRUE)::numeric /
        NULLIF(c.max_capacity, 0)) * 100,
        2
    ) AS occupancy_rate,
    COUNT(*) FILTER (WHERE a.is_no_show = TRUE) AS no_show_count,
    COUNT(*) FILTER (WHERE a.is_walk_in = TRUE) AS walk_in_count,
    c.max_capacity,
    c.start_datetime
FROM courses c
LEFT JOIN attendances a ON c.id = a.course_id
WHERE c.deleted_at IS NULL
    AND c.status IN ('completed', 'scheduled')
GROUP BY c.id, c.organization_id, c.title, c.course_type, c.day_of_week, c.month, c.year, c.max_capacity, c.start_datetime;

CREATE UNIQUE INDEX idx_mv_-- ============================================
-- SCHÉMA DE BASE DE DONNÉES - KRAVSTATS
-- PostgreSQL 15+
-- Multi-tenant avec Row Level Security
-- ============================================

-- Extensions nécessaires
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- ============================================
-- TABLE: organizations (Clubs/Tenants)
-- ============================================
CREATE TABLE organizations (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    
    -- Identité
    name VARCHAR(255) NOT NULL CHECK (char_length(name) >= 2),
    slug VARCHAR(100) UNIQUE NOT NULL CHECK (slug ~ '^[a-z0-9-]+$'),
    
    -- Contact
    email VARCHAR(255) CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}$'),
    phone VARCHAR(20),
    address TEXT,
    
    -- Branding
    logo_url VARCHAR(500),
    
    -- Configuration (JSONB pour flexibilité)
    settings JSONB NOT NULL DEFAULT '{
        "lock_attendance_by_coach": true,
        "default_capacity": 15,
        "season_start_month": 9,
        "timezone": "Europe/Paris"
    }'::jsonb,
    
    -- Abonnement
    subscription_status VARCHAR(20) NOT NULL DEFAULT 'trial' 
        CHECK (subscription_status IN ('trial', 'active', 'past_due', 'canceled', 'suspended')),
    subscription_plan VARCHAR(20) DEFAULT 'free'
        CHECK (subscription_plan IN ('free', 'pro', 'premium')),
    trial_ends_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index
CREATE INDEX idx_organizations_slug ON organizations(slug) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_subscription_status ON organizations(subscription_status) WHERE deleted_at IS NULL;
CREATE INDEX idx_organizations_trial_ends ON organizations(trial_ends_at) WHERE trial_ends_at IS NOT NULL;

-- Trigger pour updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_organizations_updated_at
    BEFORE UPDATE ON organizations
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE organizations IS 'Clubs/Associations (tenants multi-tenant)';
COMMENT ON COLUMN organizations.settings IS 'Configuration JSON: lock_attendance_by_coach, default_capacity, etc.';


-- ============================================
-- TABLE: users (Tous les utilisateurs)
-- ============================================
CREATE TABLE users (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Authentification
    email VARCHAR(255) NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+[.][A-Za-z]{2,}$'),
    password_hash VARCHAR(255) NOT NULL,
    
    -- Identité
    first_name VARCHAR(100) NOT NULL CHECK (char_length(first_name) >= 1),
    last_name VARCHAR(100) NOT NULL CHECK (char_length(last_name) >= 1),
    phone VARCHAR(20),
    date_of_birth DATE CHECK (date_of_birth < CURRENT_DATE),
    
    -- Rôle et statut
    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'coach', 'member')),
    status VARCHAR(20) NOT NULL DEFAULT 'active' 
        CHECK (status IN ('active', 'inactive', 'suspended')),
    
    -- Dates importantes
    join_date DATE NOT NULL DEFAULT CURRENT_DATE,
    
    -- Métadonnées flexibles (ceintures, certificat médical, etc.)
    metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Sécurité
    email_verified BOOLEAN NOT NULL DEFAULT FALSE,
    last_login_at TIMESTAMP WITH TIME ZONE,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Constraints
    CONSTRAINT users_email_org_unique UNIQUE (email, organization_id)
);

-- Index optimisés
CREATE UNIQUE INDEX idx_users_email_org ON users(email, organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_organization_id ON users(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_role ON users(organization_id, role) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_status ON users(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_users_password_reset ON users(password_reset_token) WHERE password_reset_token IS NOT NULL;
CREATE INDEX idx_users_metadata_gin ON users USING gin(metadata jsonb_path_ops);

-- Row Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

CREATE POLICY users_isolation ON users
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE users IS 'Tous les utilisateurs (admins, coachs, adhérents)';
COMMENT ON COLUMN users.metadata IS 'Données flexibles: belt_level, medical_cert, preferences, etc.';
COMMENT ON COLUMN users.password_hash IS 'Hash bcrypt du mot de passe (coût 12)';


-- ============================================
-- TABLE: courses (Cours ponctuels et récurrents)
-- ============================================
CREATE TABLE courses (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Informations de base
    title VARCHAR(255) NOT NULL CHECK (char_length(title) >= 2),
    description TEXT,
    course_type VARCHAR(50),
    
    -- Horaires
    start_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    end_datetime TIMESTAMP WITH TIME ZONE NOT NULL,
    CHECK (end_datetime > start_datetime),
    
    -- Lieu
    location VARCHAR(255),
    
    -- Coach
    coach_id UUID REFERENCES users(id) ON DELETE SET NULL,
    
    -- Capacité
    max_capacity INTEGER CHECK (max_capacity > 0 OR max_capacity IS NULL),
    
    -- Récurrence
    is_recurring BOOLEAN NOT NULL DEFAULT FALSE,
    recurrence_rule JSONB CHECK (
        recurrence_rule IS NULL OR 
        (recurrence_rule ? 'frequency' AND recurrence_rule ? 'day_of_week')
    ),
    parent_recurrence_id UUID REFERENCES courses(id) ON DELETE SET NULL,
    
    -- Statut
    status VARCHAR(20) NOT NULL DEFAULT 'scheduled'
        CHECK (status IN ('scheduled', 'ongoing', 'completed', 'cancelled')),
    cancellation_reason TEXT,
    cancelled_at TIMESTAMP WITH TIME ZONE,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb
);

-- Index haute performance
CREATE INDEX idx_courses_organization_id ON courses(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_start_datetime ON courses(organization_id, start_datetime DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_coach_id ON courses(coach_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_status ON courses(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_parent_recurrence ON courses(parent_recurrence_id) WHERE parent_recurrence_id IS NOT NULL;
CREATE INDEX idx_courses_date_range ON courses(organization_id, start_datetime, end_datetime) WHERE deleted_at IS NULL;
CREATE INDEX idx_courses_recurrence_gin ON courses USING gin(recurrence_rule jsonb_path_ops) WHERE recurrence_rule IS NOT NULL;

-- Index pour recherches temporelles optimisées
CREATE INDEX idx_courses_upcoming ON courses(organization_id, start_datetime) 
    WHERE status = 'scheduled' AND deleted_at IS NULL;
CREATE INDEX idx_courses_past ON courses(organization_id, start_datetime DESC) 
    WHERE status = 'completed' AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE courses ENABLE ROW LEVEL SECURITY;

CREATE POLICY courses_isolation ON courses
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_courses_updated_at
    BEFORE UPDATE ON courses
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE courses IS 'Cours (ponctuels et récurrents avec occurrences)';
COMMENT ON COLUMN courses.recurrence_rule IS 'Règle de récurrence JSON: {frequency: "weekly", day_of_week: 1, end_date: "2026-06-30"}';
COMMENT ON COLUMN courses.parent_recurrence_id IS 'Lien vers le cours parent si occurrence de récurrence';


-- ============================================
-- TABLE: attendances (Présences et intentions)
-- ============================================
CREATE TABLE attendances (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    course_id UUID NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- Intention (avant le cours)
    intention VARCHAR(20) CHECK (intention IN ('will_attend', 'will_not_attend') OR intention IS NULL),
    intention_at TIMESTAMP WITH TIME ZONE,
    
    -- Présence effective (pendant/après le cours)
    actual_attendance BOOLEAN,
    actual_attendance_at TIMESTAMP WITH TIME ZONE,
    
    -- Traçabilité
    marked_by_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    marked_by_role VARCHAR(20) CHECK (marked_by_role IN ('admin', 'coach', 'member') OR marked_by_role IS NULL),
    is_locked BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- Notes
    notes TEXT,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Métadonnées
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contrainte unicité
    CONSTRAINT attendances_course_user_unique UNIQUE (course_id, user_id)
);

-- Index critiques pour performance
CREATE UNIQUE INDEX idx_attendances_course_user ON attendances(course_id, user_id);
CREATE INDEX idx_attendances_organization_id ON attendances(organization_id);
CREATE INDEX idx_attendances_user_id ON attendances(user_id);
CREATE INDEX idx_attendances_course_id ON attendances(course_id);

-- Index pour statistiques optimisées
CREATE INDEX idx_attendances_actual ON attendances(organization_id, user_id, actual_attendance) 
    WHERE actual_attendance IS NOT NULL;
CREATE INDEX idx_attendances_intention ON attendances(organization_id, course_id, intention) 
    WHERE intention IS NOT NULL;
CREATE INDEX idx_attendances_user_actual_date ON attendances(user_id, actual_attendance_at) 
    WHERE actual_attendance = TRUE;

-- Index composite pour requêtes fréquentes
CREATE INDEX idx_attendances_stats ON attendances(organization_id, user_id, actual_attendance, actual_attendance_at)
    WHERE actual_attendance IS NOT NULL;

-- Row Level Security
ALTER TABLE attendances ENABLE ROW LEVEL SECURITY;

CREATE POLICY attendances_isolation ON attendances
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_attendances_updated_at
    BEFORE UPDATE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE attendances IS 'Intentions et présences effectives aux cours';
COMMENT ON COLUMN attendances.intention IS 'Déclaration avant cours: will_attend ou will_not_attend';
COMMENT ON COLUMN attendances.actual_attendance IS 'Présence réelle: true = présent, false = absent, null = non encore marqué';
COMMENT ON COLUMN attendances.is_locked IS 'Verrouillage selon paramètre organisation';


-- ============================================
-- TABLE: subscriptions (Abonnements Stripe)
-- ============================================
CREATE TABLE subscriptions (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL UNIQUE REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Stripe
    stripe_customer_id VARCHAR(255) UNIQUE,
    stripe_subscription_id VARCHAR(255) UNIQUE,
    stripe_payment_method_id VARCHAR(255),
    
    -- Plan
    plan VARCHAR(20) NOT NULL CHECK (plan IN ('free', 'pro', 'premium')),
    status VARCHAR(20) NOT NULL 
        CHECK (status IN ('trialing', 'active', 'past_due', 'canceled', 'unpaid', 'incomplete')),
    
    -- Limites
    max_members INTEGER,
    features JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    -- Dates
    current_period_start TIMESTAMP WITH TIME ZONE,
    current_period_end TIMESTAMP WITH TIME ZONE,
    trial_end TIMESTAMP WITH TIME ZONE,
    canceled_at TIMESTAMP WITH TIME ZONE,
    ended_at TIMESTAMP WITH TIME ZONE,
    
    -- Facturation
    amount_cents INTEGER CHECK (amount_cents >= 0),
    currency VARCHAR(3) NOT NULL DEFAULT 'EUR',
    interval VARCHAR(20) CHECK (interval IN ('month', 'year')),
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index
CREATE INDEX idx_subscriptions_organization_id ON subscriptions(organization_id);
CREATE INDEX idx_subscriptions_stripe_customer ON subscriptions(stripe_customer_id);
CREATE INDEX idx_subscriptions_status ON subscriptions(status);
CREATE INDEX idx_subscriptions_trial_end ON subscriptions(trial_end) WHERE trial_end IS NOT NULL;

-- Trigger
CREATE TRIGGER update_subscriptions_updated_at
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE subscriptions IS 'Abonnements et facturation Stripe';
COMMENT ON COLUMN subscriptions.features IS 'Fonctionnalités actives selon plan';


-- ============================================
-- TABLE: custom_fields (Champs personnalisés)
-- ============================================
CREATE TABLE custom_fields (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Définition
    field_name VARCHAR(100) NOT NULL,
    field_key VARCHAR(50) NOT NULL CHECK (field_key ~ '^[a-z_]+$'),
    field_type VARCHAR(20) NOT NULL 
        CHECK (field_type IN ('text', 'number', 'date', 'boolean', 'select', 'multi_select')),
    field_options JSONB DEFAULT '{}'::jsonb,
    
    -- Comportement
    is_required BOOLEAN NOT NULL DEFAULT FALSE,
    show_in_stats BOOLEAN NOT NULL DEFAULT FALSE,
    display_order INTEGER NOT NULL DEFAULT 0,
    
    -- Audit
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Contrainte unicité
    CONSTRAINT custom_fields_org_key_unique UNIQUE (organization_id, field_key)
);

-- Index
CREATE INDEX idx_custom_fields_organization ON custom_fields(organization_id, display_order) 
    WHERE deleted_at IS NULL;
CREATE INDEX idx_custom_fields_stats ON custom_fields(organization_id) 
    WHERE show_in_stats = TRUE AND deleted_at IS NULL;

-- Row Level Security
ALTER TABLE custom_fields ENABLE ROW LEVEL SECURITY;

CREATE POLICY custom_fields_isolation ON custom_fields
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Trigger
CREATE TRIGGER update_custom_fields_updated_at
    BEFORE UPDATE ON custom_fields
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Commentaires
COMMENT ON TABLE custom_fields IS 'Définition des champs personnalisés par organisation';
COMMENT ON COLUMN custom_fields.field_options IS 'Options JSON: {values: ["Option1", "Option2"]} pour select';


-- ============================================
-- TABLE: audit_logs (Traçabilité)
-- ============================================
CREATE TABLE audit_logs (
    -- Clés
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    
    -- Qui
    user_id UUID REFERENCES users(id) ON DELETE SET NULL,
    user_email VARCHAR(255),
    user_role VARCHAR(20),
    
    -- Quoi
    action VARCHAR(100) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID,
    
    -- Détails
    changes JSONB DEFAULT '{}'::jsonb,
    metadata JSONB DEFAULT '{}'::jsonb,
    
    -- Contexte
    ip_address INET,
    user_agent TEXT,
    
    -- Quand
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Index pour requêtes fréquentes
CREATE INDEX idx_audit_logs_organization ON audit_logs(organization_id, created_at DESC);
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_entity ON audit_logs(entity_type, entity_id);
CREATE INDEX idx_audit_logs_created ON audit_logs(created_at DESC);

-- Partitionnement par date (recommandé si gros volume)
-- CREATE TABLE audit_logs_2025_10 PARTITION OF audit_logs
--     FOR VALUES FROM ('2025-10-01') TO ('2025-11-01');

-- Row Level Security
ALTER TABLE audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY audit_logs_isolation ON audit_logs
    USING (organization_id = current_setting('app.current_tenant', true)::uuid);

-- Commentaires
COMMENT ON TABLE audit_logs IS 'Logs de toutes les actions utilisateurs (traçabilité complète)';
COMMENT ON COLUMN audit_logs.changes IS 'Changements JSON: {before: {...}, after: {...}}';


-- ============================================
-- VUES MATÉRIALISÉES (Performance)
-- ============================================

-- Vue: Statistiques adhérents pré-calculées
CREATE MATERIALIZED VIEW mv_member_stats AS
SELECT 
    u.id AS user_id,
    u.organization_id,
    u.first_name,
    u.last_name,
    COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled') AS available_courses,
    ROUND(
        (COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE)::numeric / 
        NULLIF(COUNT(DISTINCT c.id) FILTER (WHERE c.status != 'cancelled'), 0)) * 100, 
        2
    ) AS attendance_rate,
    MAX(a.actual_attendance_at) AS last_attendance_date,
    CURRENT_DATE - MAX(a.actual_attendance_at)::date AS days_since_last_attendance
FROM users u
LEFT JOIN attendances a ON u.id = a.user_id
LEFT JOIN courses c ON a.course_id = c.id
WHERE u.deleted_at IS NULL 
    AND u.role = 'member'
    AND c.start_datetime >= CURRENT_DATE - INTERVAL '3 months'
GROUP BY u.id, u.organization_id, u.first_name, u.last_name;

-- Index sur vue matérialisée
CREATE UNIQUE INDEX idx_mv_member_stats_user ON mv_member_stats(user_id);
CREATE INDEX idx_mv_member_stats_org ON mv_member_stats(organization_id);
CREATE INDEX idx_mv_member_stats_rate ON mv_member_stats(organization_id, attendance_rate DESC);

-- Commentaire
COMMENT ON MATERIALIZED VIEW mv_member_stats IS 'Stats adhérents pré-calculées (refresh quotidien recommandé)';

-- Fonction de refresh automatique (à scheduler)
CREATE OR REPLACE FUNCTION refresh_member_stats()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_stats;
END;
$$ LANGUAGE plpgsql;


-- ============================================
-- FONCTIONS UTILITAIRES
-- ============================================

-- Fonction: Définir le tenant courant (pour RLS)
CREATE OR REPLACE FUNCTION set_current_tenant(tenant_id UUID)
RETURNS void AS $$
BEGIN
    PERFORM set_config('app.current_tenant', tenant_id::text, false);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION set_current_tenant IS 'Définit le tenant courant pour Row Level Security';


-- Fonction: Calculer le taux de présence d'un adhérent
CREATE OR REPLACE FUNCTION calculate_attendance_rate(
    p_user_id UUID,
    p_start_date TIMESTAMP WITH TIME ZONE DEFAULT NULL,
    p_end_date TIMESTAMP WITH TIME ZONE DEFAULT NULL
)
RETURNS NUMERIC AS $$
DECLARE
    v_attendances INTEGER;
    v_available_courses INTEGER;
BEGIN
    -- Compte les présences effectives
    SELECT COUNT(*) INTO v_attendances
    FROM attendances a
    INNER JOIN courses c ON a.course_id = c.id
    WHERE a.user_id = p_user_id
        AND a.actual_attendance = TRUE
        AND (p_start_date IS NULL OR c.start_datetime >= p_start_date)
        AND (p_end_date IS NULL OR c.start_datetime <= p_end_date);
    
    -- Compte les cours disponibles (non annulés)
    SELECT COUNT(DISTINCT c.id) INTO v_available_courses
    FROM courses c
    WHERE c.organization_id = (SELECT organization_id FROM users WHERE id = p_user_id)
        AND c.status != 'cancelled'
        AND (p_start_date IS NULL OR c.start_datetime >= p_start_date)
        AND (p_end_date IS NULL OR c.start_datetime <= p_end_date);
    
    -- Calcul du taux
    IF v_available_courses = 0 THEN
        RETURN 0;
    END IF;
    
    RETURN ROUND((v_attendances::numeric / v_available_courses) * 100, 2);
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION calculate_attendance_rate IS 'Calcule le taux de présence d''un adhérent sur une période';


-- Fonction: Détecter les adhérents à risque d'abandon
CREATE OR REPLACE FUNCTION detect_at_risk_members(
    p_organization_id UUID,
    p_days_threshold INTEGER DEFAULT 21
)
RETURNS TABLE (
    user_id UUID,
    user_name TEXT,
    days_absent INTEGER,
    previous_rate NUMERIC,
    risk_level TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        u.id,
        u.first_name || ' ' || u.last_name,
        CURRENT_DATE - MAX(a.actual_attendance_at)::date,
        calculate_attendance_rate(u.id, CURRENT_DATE - INTERVAL '3 months', CURRENT_DATE - INTERVAL '1 month'),
        CASE 
            WHEN CURRENT_DATE - MAX(a.actual_attendance_at)::date >= 30 THEN 'critical'
            WHEN CURRENT_DATE - MAX(a.actual_attendance_at)::date >= p_days_threshold THEN 'warning'
            ELSE 'normal'
        END
    FROM users u
    LEFT JOIN attendances a ON u.id = a.user_id AND a.actual_attendance = TRUE
    WHERE u.organization_id = p_organization_id
        AND u.role = 'member'
        AND u.status = 'active'
        AND u.deleted_at IS NULL
    GROUP BY u.id, u.first_name, u.last_name
    HAVING MAX(a.actual_attendance_at) IS NOT NULL
        AND CURRENT_DATE - MAX(a.actual_attendance_at)::date >= p_days_threshold
    ORDER BY CURRENT_DATE - MAX(a.actual_attendance_at)::date DESC;
END;
$$ LANGUAGE plpgsql STABLE;

COMMENT ON FUNCTION detect_at_risk_members IS 'Détecte les adhérents absents depuis X jours (risque abandon)';


-- ============================================
-- TRIGGERS AVANCÉS
-- ============================================

-- Trigger: Auto-update subscription_status dans organizations
CREATE OR REPLACE FUNCTION sync_subscription_status()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE organizations 
    SET subscription_status = NEW.status
    WHERE id = NEW.organization_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER sync_subscription_to_org
    AFTER INSERT OR UPDATE OF status ON subscriptions
    FOR EACH ROW
    EXECUTE FUNCTION sync_subscription_status();


-- Trigger: Audit automatique sur modifications importantes
CREATE OR REPLACE FUNCTION log_important_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO audit_logs (
            organization_id,
            user_id,
            action,
            entity_type,
            entity_id,
            changes
        ) VALUES (
            NEW.organization_id,
            current_setting('app.current_user_id', true)::uuid,
            TG_TABLE_NAME || '.updated',
            TG_TABLE_NAME,
            NEW.id,
            jsonb_build_object('before', to_jsonb(OLD), 'after', to_jsonb(NEW))
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit_logs (
            organization_id,
            user_id,
            action,
            entity_type,
            entity_id,
            changes
        ) VALUES (
            OLD.organization_id,
            current_setting('app.current_user_id', true)::uuid,
            TG_TABLE_NAME || '.deleted',
            TG_TABLE_NAME,
            OLD.id,
            jsonb_build_object('before', to_jsonb(OLD))
        );
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Appliquer l'audit sur les tables critiques
CREATE TRIGGER audit_courses_changes
    AFTER UPDATE OR DELETE ON courses
    FOR EACH ROW
    EXECUTE FUNCTION log_important_changes();

CREATE TRIGGER audit_attendances_changes
    AFTER UPDATE OR DELETE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION log_important_changes();


-- ============================================
-- CONTRAINTES D'INTÉGRITÉ AVANCÉES
-- ============================================

-- Vérifier que le coach appartient à l'organisation
ALTER TABLE courses ADD CONSTRAINT check_coach_organization
    CHECK (
        coach_id IS NULL OR 
        EXISTS (
            SELECT 1 FROM users 
            WHERE id = coach_id 
            AND organization_id = courses.organization_id
            AND role IN ('coach', 'admin')
        )
    );

-- Vérifier cohérence des dates de récurrence
ALTER TABLE courses ADD CONSTRAINT check_recurrence_dates
    CHECK (
        NOT is_recurring OR 
        (recurrence_rule IS NOT NULL)
    );


-- ============================================
-- GRANTS ET SÉCURITÉ
-- ============================================

-- Rôle application (utilisé par le backend)
CREATE ROLE app_user WITH LOGIN PASSWORD 'change_me_in_production';

-- Permissions strictes
GRANT CONNECT ON DATABASE postgres TO app_user;
GRANT USAGE ON SCHEMA public TO app_user;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO app_user;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO app_user;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO app_user;

-- Lecture seule pour les rapports
CREATE ROLE app_readonly WITH LOGIN PASSWORD 'change_me_readonly';
GRANT CONNECT ON DATABASE postgres TO app_readonly;
GRANT USAGE ON SCHEMA public TO app_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO app_readonly;


-- ============================================
-- DONNÉES DE TEST (Optionnel)
-- ============================================

-- Insertion organisation de test
INSERT INTO organizations (id, name, slug, email, subscription_plan, subscription_status)
VALUES (
    'a0000000-0000-0000-0000-000000000001',
    'Krav Maga Lyon Centre',
    'krav-maga-lyon-centre',
    'contact@kravlyon.fr',
    'pro',
    'active'
);

-- Insertion utilisateurs de test
INSERT INTO users (organization_id, email, password_hash, first_name, last_name, role)
VALUES 
    ('a0000000-0000-0000-0000-000000000001', 'admin@kravlyon.fr', '$2b$12$dummy_hash', 'Sophie', 'Bernard', 'admin'),
    ('a0000000-0000-0000-0000-000000000001', 'marc@kravlyon.fr', '$2b$12$dummy_hash', 'Marc', 'Petit', 'coach'),
    ('a0000000-0000-0000-0000-000000000001', 'lisa@email.com', '$2b$12$dummy_hash', 'Lisa', 'Martin', 'member');


-- ============================================
-- MAINTENANCE ET MONITORING
-- ============================================

-- ============================================
-- MAINTENANCE ET MONITORING
-- ============================================

-- Vue pour monitoring des performances
CREATE VIEW v_table_sizes AS
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) AS indexes_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

COMMENT ON VIEW v_table_sizes IS 'Taille des tables et indexes pour monitoring';


-- Vue pour monitoring des index inutilisés
CREATE VIEW v_unused_indexes AS
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
    AND indexrelname NOT LIKE 'pg_toast%'
    AND schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;

COMMENT ON VIEW v_unused_indexes IS 'Index jamais utilisés (candidats pour suppression)';


-- Vue pour monitoring des connexions actives
CREATE VIEW v_active_connections AS
SELECT 
    datname,
    usename,
    application_name,
    client_addr,
    state,
    query_start,
    state_change,
    wait_event_type,
    wait_event,
    LEFT(query, 100) AS query_preview
FROM pg_stat_activity
WHERE datname = current_database()
    AND pid != pg_backend_pid()
ORDER BY query_start;

COMMENT ON VIEW v_active_connections IS 'Connexions actives à la base de données';


-- Vue pour statistiques par organisation
CREATE VIEW v_organization_stats AS
SELECT 
    o.id,
    o.name,
    o.subscription_plan,
    COUNT(DISTINCT u.id) FILTER (WHERE u.role = 'member' AND u.deleted_at IS NULL) AS total_members,
    COUNT(DISTINCT u.id) FILTER (WHERE u.role = 'coach' AND u.deleted_at IS NULL) AS total_coaches,
    COUNT(DISTINCT c.id) FILTER (WHERE c.deleted_at IS NULL) AS total_courses,
    COUNT(DISTINCT a.id) FILTER (WHERE a.actual_attendance = TRUE) AS total_attendances,
    ROUND(
        AVG(
            (SELECT calculate_attendance_rate(u2.id, CURRENT_DATE - INTERVAL '30 days', CURRENT_DATE)
             FROM users u2 
             WHERE u2.organization_id = o.id AND u2.role = 'member' AND u2.deleted_at IS NULL)
        ), 2
    ) AS avg_attendance_rate_30d
FROM organizations o
LEFT JOIN users u ON o.id = u.organization_id
LEFT JOIN courses c ON o.id = c.organization_id
LEFT JOIN attendances a ON o.id = a.organization_id
WHERE o.deleted_at IS NULL
GROUP BY o.id, o.name, o.subscription_plan;

COMMENT ON VIEW v_organization_stats IS 'Statistiques agrégées par organisation';


-- ============================================
-- PROCÉDURES DE MAINTENANCE
-- ============================================

-- Procédure: Nettoyage des données obsolètes
CREATE OR REPLACE PROCEDURE cleanup_old_data(
    p_audit_logs_retention_days INTEGER DEFAULT 365,
    p_deleted_records_retention_days INTEGER DEFAULT 90
)
LANGUAGE plpgsql
AS $
BEGIN
    -- Supprimer les vieux logs d'audit
    DELETE FROM audit_logs 
    WHERE created_at < CURRENT_DATE - (p_audit_logs_retention_days || ' days')::INTERVAL;
    
    RAISE NOTICE 'Audit logs nettoyés: % lignes supprimées', 
        (SELECT count(*) FROM audit_logs WHERE created_at < CURRENT_DATE - (p_audit_logs_retention_days || ' days')::INTERVAL);
    
    -- Supprimer définitivement les enregistrements soft-deleted anciens
    DELETE FROM users 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    DELETE FROM courses 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    DELETE FROM organizations 
    WHERE deleted_at IS NOT NULL 
        AND deleted_at < CURRENT_DATE - (p_deleted_records_retention_days || ' days')::INTERVAL;
    
    RAISE NOTICE 'Nettoyage terminé';
END;
$;

COMMENT ON PROCEDURE cleanup_old_data IS 'Nettoyage automatique des données obsolètes (à scheduler)';


-- Procédure: Vacuum et analyse automatiques
CREATE OR REPLACE PROCEDURE maintenance_vacuum_analyze()
LANGUAGE plpgsql
AS $
BEGIN
    VACUUM ANALYZE organizations;
    VACUUM ANALYZE users;
    VACUUM ANALYZE courses;
    VACUUM ANALYZE attendances;
    VACUUM ANALYZE subscriptions;
    VACUUM ANALYZE custom_fields;
    VACUUM ANALYZE audit_logs;
    
    RAISE NOTICE 'Vacuum et analyse terminés';
END;
$;

COMMENT ON PROCEDURE maintenance_vacuum_analyze IS 'Vacuum et analyse des tables principales (à scheduler quotidiennement)';


-- Procédure: Refresh des vues matérialisées
CREATE OR REPLACE PROCEDURE refresh_all_materialized_views()
LANGUAGE plpgsql
AS $
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_member_stats;
    RAISE NOTICE 'Vues matérialisées rafraîchies';
END;
$;

COMMENT ON PROCEDURE refresh_all_materialized_views IS 'Rafraîchissement de toutes les vues matérialisées (à scheduler quotidiennement)';


-- ============================================
-- BACKUP ET RESTORE
-- ============================================

-- Fonction: Export des données d'une organisation (RGPD)
CREATE OR REPLACE FUNCTION export_organization_data(p_organization_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $
DECLARE
    v_data JSONB;
BEGIN
    SELECT jsonb_build_object(
        'organization', (SELECT row_to_json(o.*) FROM organizations o WHERE id = p_organization_id),
        'users', (SELECT jsonb_agg(row_to_json(u.*)) FROM users u WHERE organization_id = p_organization_id AND deleted_at IS NULL),
        'courses', (SELECT jsonb_agg(row_to_json(c.*)) FROM courses c WHERE organization_id = p_organization_id AND deleted_at IS NULL),
        'attendances', (SELECT jsonb_agg(row_to_json(a.*)) FROM attendances a WHERE organization_id = p_organization_id),
        'custom_fields', (SELECT jsonb_agg(row_to_json(cf.*)) FROM custom_fields cf WHERE organization_id = p_organization_id AND deleted_at IS NULL)
    ) INTO v_data;
    
    RETURN v_data;
END;
$;

COMMENT ON FUNCTION export_organization_data IS 'Export complet des données d''une organisation (conformité RGPD)';


-- Fonction: Anonymisation d'un utilisateur (RGPD - droit à l'oubli)
CREATE OR REPLACE FUNCTION anonymize_user(p_user_id UUID)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $
BEGIN
    UPDATE users
    SET 
        email = 'deleted_' || id || '@anonymized.local',
        first_name = 'Utilisateur',
        last_name = '[Supprimé]',
        phone = NULL,
        date_of_birth = NULL,
        metadata = '{}'::jsonb,
        password_hash = 'ANONYMIZED',
        deleted_at = CURRENT_TIMESTAMP
    WHERE id = p_user_id;
    
    -- Log de l'action
    INSERT INTO audit_logs (
        organization_id,
        user_id,
        action,
        entity_type,
        entity_id,
        metadata
    ) VALUES (
        (SELECT organization_id FROM users WHERE id = p_user_id),
        p_user_id,
        'user.anonymized',
        'users',
        p_user_id,
        jsonb_build_object('anonymized_at', CURRENT_TIMESTAMP, 'reason', 'RGPD_right_to_be_forgotten')
    );
    
    RAISE NOTICE 'Utilisateur % anonymisé', p_user_id;
END;
$;

COMMENT ON FUNCTION anonymize_user IS 'Anonymisation d''un utilisateur (RGPD - droit à l''oubli)';


-- ============================================
-- INDEXES PARTIELS AVANCÉS (Optimisation)
-- ============================================

-- Index pour les cours à venir uniquement (requête très fréquente)
CREATE INDEX idx_courses_upcoming_detailed ON courses(organization_id, start_datetime, status)
    WHERE start_datetime > CURRENT_TIMESTAMP 
        AND status = 'scheduled' 
        AND deleted_at IS NULL;

-- Index pour les adhérents actifs récents
CREATE INDEX idx_users_active_recent ON users(organization_id, last_login_at DESC)
    WHERE status = 'active' 
        AND deleted_at IS NULL
        AND last_login_at > CURRENT_TIMESTAMP - INTERVAL '30 days';

-- Index pour présences du mois en cours (statistiques temps réel)
CREATE INDEX idx_attendances_current_month ON attendances(organization_id, user_id, actual_attendance)
    WHERE actual_attendance_at >= date_trunc('month', CURRENT_DATE)
        AND actual_attendance IS NOT NULL;


-- ============================================
-- POLICIES RLS AVANCÉES (Sécurité fine)
-- ============================================

-- Policy: Les coachs ne voient que leurs cours
CREATE POLICY coaches_own_courses ON courses
    FOR SELECT
    USING (
        organization_id = current_setting('app.current_tenant', true)::uuid
        AND (
            coach_id = current_setting('app.current_user_id', true)::uuid
            OR EXISTS (
                SELECT 1 FROM users 
                WHERE id = current_setting('app.current_user_id', true)::uuid 
                AND role IN ('admin')
            )
        )
    );

-- Policy: Les adhérents ne voient que leurs propres présences détaillées
CREATE POLICY members_own_attendances ON attendances
    FOR SELECT
    USING (
        organization_id = current_setting('app.current_tenant', true)::uuid
        AND (
            user_id = current_setting('app.current_user_id', true)::uuid
            OR EXISTS (
                SELECT 1 FROM users 
                WHERE id = current_setting('app.current_user_id', true)::uuid 
                AND role IN ('admin', 'coach')
            )
        )
    );


-- ============================================
-- CONTRAINTES DE VALIDATION MÉTIER
-- ============================================

-- Vérifier qu'un cours ne dépasse pas 24h
ALTER TABLE courses ADD CONSTRAINT check_course_max_duration
    CHECK (end_datetime - start_datetime <= INTERVAL '24 hours');

-- Vérifier qu'on ne peut pas marquer présent à un cours dans le futur
CREATE OR REPLACE FUNCTION check_attendance_not_future()
RETURNS TRIGGER AS $
BEGIN
    IF NEW.actual_attendance IS NOT NULL AND NEW.actual_attendance_at IS NOT NULL THEN
        IF NEW.actual_attendance_at > (SELECT end_datetime FROM courses WHERE id = NEW.course_id) + INTERVAL '2 hours' THEN
            RAISE EXCEPTION 'Impossible de marquer une présence plus de 2h après la fin du cours';
        END IF;
    END IF;
    RETURN NEW;
END;
$ LANGUAGE plpgsql;

CREATE TRIGGER validate_attendance_timing
    BEFORE INSERT OR UPDATE ON attendances
    FOR EACH ROW
    EXECUTE FUNCTION check_attendance_not_future();


-- ============================================
-- FONCTIONS D'AGRÉGATION PERSONNALISÉES
-- ============================================

-- Fonction: Statistiques complètes d'un adhérent
CREATE OR REPLACE FUNCTION get_member_complete_stats(p_user_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $
DECLARE
    v_stats JSONB;
BEGIN
    SELECT jsonb_build_object(
        'user_id', p_user_id,
        'total_courses_available', (
            SELECT COUNT(*) 
            FROM courses c
            WHERE c.organization_id = (SELECT organization_id FROM users WHERE id = p_user_id)
                AND c.status != 'cancelled'
                AND c.start_datetime >= (SELECT join_date FROM users WHERE id = p_user_id)
                AND c.deleted_at IS NULL
        ),
        'total_attendances', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'attendance_rate', calculate_attendance_rate(p_user_id),
        'attendance_rate_30d', calculate_attendance_rate(p_user_id, CURRENT_DATE - INTERVAL '30 days', CURRENT_DATE),
        'attendance_rate_90d', calculate_attendance_rate(p_user_id, CURRENT_DATE - INTERVAL '90 days', CURRENT_DATE),
        'last_attendance', (
            SELECT MAX(actual_attendance_at) 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'days_since_last_attendance', (
            SELECT CURRENT_DATE - MAX(actual_attendance_at)::date 
            FROM attendances 
            WHERE user_id = p_user_id AND actual_attendance = TRUE
        ),
        'current_streak', (
            -- Série de présences consécutives (simplifié)
            SELECT COUNT(*)
            FROM attendances a
            INNER JOIN courses c ON a.course_id = c.id
            WHERE a.user_id = p_user_id 
                AND a.actual_attendance = TRUE
                AND c.start_datetime >= CURRENT_DATE - INTERVAL '30 days'
        ),
        'total_intentions', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE user_id = p_user_id AND intention = 'will_attend'
        ),
        'intention_reliability', (
            -- Fiabilité des inscriptions
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE intention = 'will_attend' AND actual_attendance = TRUE)::numeric /
                NULLIF(COUNT(*) FILTER (WHERE intention = 'will_attend'), 0)) * 100, 2
            )
            FROM attendances
            WHERE user_id = p_user_id
        )
    ) INTO v_stats;
    
    RETURN v_stats;
END;
$;

COMMENT ON FUNCTION get_member_complete_stats IS 'Statistiques complètes d''un adhérent (toutes périodes)';


-- Fonction: Statistiques d'un cours
CREATE OR REPLACE FUNCTION get_course_stats(p_course_id UUID)
RETURNS JSONB
LANGUAGE plpgsql
STABLE
AS $
DECLARE
    v_stats JSONB;
BEGIN
    SELECT jsonb_build_object(
        'course_id', p_course_id,
        'total_enrolled', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE course_id = p_course_id AND intention = 'will_attend'
        ),
        'total_attended', (
            SELECT COUNT(*) 
            FROM attendances 
            WHERE course_id = p_course_id AND actual_attendance = TRUE
        ),
        'occupancy_rate', (
            SELECT CASE 
                WHEN c.max_capacity IS NOT NULL THEN
                    ROUND((COUNT(a.id) FILTER (WHERE a.actual_attendance = TRUE)::numeric / c.max_capacity) * 100, 2)
                ELSE NULL
            END
            FROM courses c
            LEFT JOIN attendances a ON c.id = a.course_id
            WHERE c.id = p_course_id
            GROUP BY c.max_capacity
        ),
        'no_show_rate', (
            -- Taux de non-présentation (inscrits mais absents)
            SELECT ROUND(
                (COUNT(*) FILTER (WHERE intention = 'will_attend' AND actual_attendance = FALSE)::numeric /
                NULLIF(COUNT(*) FILTER (WHERE intention = 'will_attend'), 0)) * 100, 2
            )
            FROM attendances
            WHERE course_id = p_course_id
        ),
        'walk_ins', (
            -- Présents non-inscrits
            SELECT COUNT(*)
            FROM attendances
            WHERE course_id = p_course_id 
                AND intention IS NULL 
                AND actual_attendance = TRUE
        )
    ) INTO v_stats;
    
    RETURN v_stats;
END;
$;

COMMENT ON FUNCTION get_course_stats IS 'Statistiques détaillées d''un cours';


-- ============================================
-- SCHEDULING (À configurer via pg_cron ou cron externe)
-- ============================================

-- Extension pg_cron (optionnelle, nécessite installation)
-- CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Exemples de tâches planifiées (à décommenter si pg_cron installé)
/*
-- Refresh des stats quotidien à 2h du matin
SELECT cron.schedule('refresh-stats', '0 2 * * *', $
    CALL refresh_all_materialized_views();
$);

-- Nettoyage hebdomadaire le dimanche à 3h
SELECT cron.schedule('cleanup-old-data', '0 3 * * 0', $
    CALL cleanup_old_data(365, 90);
$);

-- Vacuum quotidien à 4h
SELECT cron.schedule('daily-vacuum', '0 4 * * *', $
    CALL maintenance_vacuum_analyze();
$);
*/


-- ============================================
-- DOCUMENTATION FINALE
-- ============================================

COMMENT ON DATABASE postgres IS 'KravStats - Application de gestion de présences sportives multi-tenant';

-- Documentation des conventions
/*
CONVENTIONS DE NOMMAGE:
- Tables: pluriel, snake_case (ex: users, courses, attendances)
- Colonnes: snake_case (ex: first_name, created_at)
- Index: idx_tablename_columns (ex: idx_users_email_org)
- Contraintes: check_tablename_description (ex: check_course_max_duration)
- Fonctions: verbe_nom (ex: calculate_attendance_rate)
- Vues matérialisées: mv_description (ex: mv_member_stats)
- Triggers: nom_action (ex: update_users_updated_at)

TYPES DE DONNÉES:
- ID: UUID (sécurité, distribution)
- Dates: TIMESTAMP WITH TIME ZONE (internationalisation)
- Textes courts: VARCHAR avec limite
- Textes longs: TEXT
- Booléens: BOOLEAN (jamais NULL si logique binaire)
- Montants: INTEGER en centimes (éviter DECIMAL pour les montants)
- Données flexibles: JSONB (indexable avec GIN)

SÉCURITÉ:
- Row Level Security (RLS) activé sur toutes les tables multi-tenant
- Soft delete (deleted_at) pour traçabilité
- Audit logs pour actions critiques
- Contraintes CHECK pour validation côté DB
- SECURITY DEFINER pour fonctions sensibles

PERFORMANCE:
- Index partiels (WHERE) pour requêtes fréquentes
- Index composites pour requêtes complexes
- Vues matérialisées pour agrégations coûteuses
- Index GIN pour JSONB
- Contraintes de clés étrangères avec ON DELETE CASCADE/SET NULL

MAINTENANCE:
- Vacuum automatique (configurer autovacuum)
- Refresh vues matérialisées quotidien
- Nettoyage logs > 1 an
- Monitoring taille tables/index
- Backup quotidien (pg_dump ou solution cloud)

SCALABILITÉ:
- Partitionnement par date pour audit_logs si > 10M lignes
- Connection pooling (PgBouncer) recommandé
- Read replicas pour reporting (PostgreSQL streaming replication)
- Sharding par organization_id si > 1000 tenants
*/


-- ============================================
-- FIN DU SCHÉMA
-- ============================================

-- Afficher un résumé
DO $
BEGIN
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Schéma de base de données créé avec succès';
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Tables créées: %', (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_type = 'BASE TABLE');
    RAISE NOTICE 'Index créés: %', (SELECT COUNT(*) FROM pg_indexes WHERE schemaname = 'public');
    RAISE NOTICE 'Fonctions créées: %', (SELECT COUNT(*) FROM pg_proc WHERE pronamespace = 'public'::regnamespace);
    RAISE NOTICE 'Triggers créés: %', (SELECT COUNT(*) FROM pg_trigger WHERE tgrelid IN (SELECT oid FROM pg_class WHERE relnamespace = 'public'::regnamespace));
    RAISE NOTICE '========================================';
    RAISE NOTICE 'Prochaines étapes:';
    RAISE NOTICE '1. Configurer les variables d''environnement';
    RAISE NOTICE '2. Créer les rôles app_user et app_readonly';
    RAISE NOTICE '3. Configurer pg_cron ou cron système pour maintenance';
    RAISE NOTICE '4. Configurer les backups automatiques';
    RAISE NOTICE '5. Tester les fonctions avec données de test';
    RAISE NOTICE '========================================';
END $;